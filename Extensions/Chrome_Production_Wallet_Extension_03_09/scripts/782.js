(self.webpackChunk_portal_portal_extension=self.webpackChunk_portal_portal_extension||[]).push([[782],{68819:(e,t,r)=>{"use strict";r.d(t,{ew:()=>Ko,nh:()=>ei});var n=r(34042);const i="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function s(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function o(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function a(e,...t){if(!s(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function c(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.createHasher");o(e.outputLen),o(e.blockLen)}function u(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function l(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function d(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function h(e,t){return e<<32-t|e>>>t}const f=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),p=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function g(e){if(a(e),f)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=p[e[r]];return t}const m={_0:48,_9:57,A:65,F:70,a:97,f:102};function y(e){return e>=m._0&&e<=m._9?e-m._0:e>=m.A&&e<=m.F?e-(m.A-10):e>=m.a&&e<=m.f?e-(m.a-10):void 0}function b(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(f)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,i=0;t<r;t++,i+=2){const r=y(e.charCodeAt(i)),s=y(e.charCodeAt(i+1));if(void 0===r||void 0===s){const t=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+i)}n[t]=16*r+s}return n}function w(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}function S(e){return"string"==typeof e&&(e=w(e)),a(e),e}function k(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];a(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const i=e[t];r.set(i,n),n+=i.length}return r}class v{}function I(e){const t=t=>e().update(S(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function B(e=32){if(i&&"function"==typeof i.getRandomValues)return i.getRandomValues(new Uint8Array(e));if(i&&"function"==typeof i.randomBytes)return Uint8Array.from(i.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}function E(e,t,r){return e&t^e&r^t&r}class x extends v{constructor(e,t,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(e),this.view=d(this.buffer)}update(e){u(this),a(e=S(e));const{view:t,buffer:r,blockLen:n}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o!==n)r.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=d(e);for(;n<=i-s;s+=n)this.process(t,s)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){u(this),function(e,t){a(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:i}=this;let{pos:s}=this;t[s++]=128,l(this.buffer.subarray(s)),this.padOffset>n-s&&(this.process(r,0),s=0);for(let e=s;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),a=Number(r&s),c=n?4:0,u=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+u,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const o=d(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=c/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<h;e++)o.setUint32(4*e,f[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:i,destroyed:s,pos:o}=this;return e.destroyed=s,e.finished=i,e.length=n,e.pos=o,n%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const A=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),O=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),_=BigInt(2**32-1),T=BigInt(32);function P(e,t=!1){return t?{h:Number(e&_),l:Number(e>>T&_)}:{h:0|Number(e>>T&_),l:0|Number(e&_)}}function j(e,t=!1){const r=e.length;let n=new Uint32Array(r),i=new Uint32Array(r);for(let s=0;s<r;s++){const{h:r,l:o}=P(e[s],t);[n[s],i[s]]=[r,o]}return[n,i]}const C=(e,t,r)=>e>>>r,R=(e,t,r)=>e<<32-r|t>>>r,z=(e,t,r)=>e>>>r|t<<32-r,N=(e,t,r)=>e<<32-r|t>>>r,U=(e,t,r)=>e<<64-r|t>>>r-32,M=(e,t,r)=>e>>>r-32|t<<64-r;function L(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:0|i}}const q=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),W=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,K=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),D=(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,$=(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0),V=(e,t,r,n,i,s)=>t+r+n+i+s+(e/2**32|0)|0,F=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),H=new Uint32Array(64);class G extends x{constructor(e=32){super(64,e,8,!1),this.A=0|A[0],this.B=0|A[1],this.C=0|A[2],this.D=0|A[3],this.E=0|A[4],this.F=0|A[5],this.G=0|A[6],this.H=0|A[7]}get(){const{A:e,B:t,C:r,D:n,E:i,F:s,G:o,H:a}=this;return[e,t,r,n,i,s,o,a]}set(e,t,r,n,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)H[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=H[e-15],r=H[e-2],n=h(t,7)^h(t,18)^t>>>3,i=h(r,17)^h(r,19)^r>>>10;H[e]=i+H[e-7]+n+H[e-16]|0}let{A:r,B:n,C:i,D:s,E:o,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(h(o,6)^h(o,11)^h(o,25))+((l=o)&a^~l&c)+F[e]+H[e]|0,d=(h(r,2)^h(r,13)^h(r,22))+E(r,n,i)|0;u=c,c=a,a=o,o=s+t|0,s=i,i=n,n=r,r=t+d|0}var l;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,i,s,o,a,c,u)}roundClean(){l(H)}destroy(){this.set(0,0,0,0,0,0,0,0),l(this.buffer)}}const J=(()=>j(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),Z=(()=>J[0])(),X=(()=>J[1])(),Y=new Uint32Array(80),Q=new Uint32Array(80);class ee extends x{constructor(e=64){super(128,e,16,!1),this.Ah=0|O[0],this.Al=0|O[1],this.Bh=0|O[2],this.Bl=0|O[3],this.Ch=0|O[4],this.Cl=0|O[5],this.Dh=0|O[6],this.Dl=0|O[7],this.Eh=0|O[8],this.El=0|O[9],this.Fh=0|O[10],this.Fl=0|O[11],this.Gh=0|O[12],this.Gl=0|O[13],this.Hh=0|O[14],this.Hl=0|O[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:i,Cl:s,Dh:o,Dl:a,Eh:c,El:u,Fh:l,Fl:d,Gh:h,Gl:f,Hh:p,Hl:g}=this;return[e,t,r,n,i,s,o,a,c,u,l,d,h,f,p,g]}set(e,t,r,n,i,s,o,a,c,u,l,d,h,f,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|s,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|u,this.Fh=0|l,this.Fl=0|d,this.Gh=0|h,this.Gl=0|f,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)Y[r]=e.getUint32(t),Q[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|Y[e-15],r=0|Q[e-15],n=z(t,r,1)^z(t,r,8)^C(t,0,7),i=N(t,r,1)^N(t,r,8)^R(t,r,7),s=0|Y[e-2],o=0|Q[e-2],a=z(s,o,19)^U(s,o,61)^C(s,0,6),c=N(s,o,19)^M(s,o,61)^R(s,o,6),u=K(i,c,Q[e-7],Q[e-16]),l=D(u,n,a,Y[e-7],Y[e-16]);Y[e]=0|l,Q[e]=0|u}let{Ah:r,Al:n,Bh:i,Bl:s,Ch:o,Cl:a,Dh:c,Dl:u,Eh:l,El:d,Fh:h,Fl:f,Gh:p,Gl:g,Hh:m,Hl:y}=this;for(let e=0;e<80;e++){const t=z(l,d,14)^z(l,d,18)^U(l,d,41),b=N(l,d,14)^N(l,d,18)^M(l,d,41),w=l&h^~l&p,S=$(y,b,d&f^~d&g,X[e],Q[e]),k=V(S,m,t,w,Z[e],Y[e]),v=0|S,I=z(r,n,28)^U(r,n,34)^U(r,n,39),B=N(r,n,28)^M(r,n,34)^M(r,n,39),E=r&i^r&o^i&o,x=n&s^n&a^s&a;m=0|p,y=0|g,p=0|h,g=0|f,h=0|l,f=0|d,({h:l,l:d}=L(0|c,0|u,0|k,0|v)),c=0|o,u=0|a,o=0|i,a=0|s,i=0|r,s=0|n;const A=q(v,B,x);r=W(A,k,I,E),n=0|A}({h:r,l:n}=L(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:s}=L(0|this.Bh,0|this.Bl,0|i,0|s)),({h:o,l:a}=L(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l:u}=L(0|this.Dh,0|this.Dl,0|c,0|u)),({h:l,l:d}=L(0|this.Eh,0|this.El,0|l,0|d)),({h,l:f}=L(0|this.Fh,0|this.Fl,0|h,0|f)),({h:p,l:g}=L(0|this.Gh,0|this.Gl,0|p,0|g)),({h:m,l:y}=L(0|this.Hh,0|this.Hl,0|m,0|y)),this.set(r,n,i,s,o,a,c,u,l,d,h,f,p,g,m,y)}roundClean(){l(Y,Q)}destroy(){l(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const te=I((()=>new G)),re=I((()=>new ee)),ne=BigInt(0),ie=BigInt(1);function se(e,t=""){if("boolean"!=typeof e){throw new Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e)}return e}function oe(e,t,r=""){const n=s(e),i=e?.length,o=void 0!==t;if(!n||o&&i!==t){throw new Error((r&&`"${r}" `)+"expected Uint8Array"+(o?` of length ${t}`:"")+", got "+(n?`length=${i}`:"type="+typeof e))}return e}function ae(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function ce(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?ne:BigInt("0x"+e)}function ue(e){return ce(g(e))}function le(e){return a(e),ce(g(Uint8Array.from(e).reverse()))}function de(e,t){return b(e.toString(16).padStart(2*t,"0"))}function he(e,t){return de(e,t).reverse()}function fe(e,t,r){let n;if("string"==typeof t)try{n=b(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!s(t))throw new Error(e+" must be hex string or Uint8Array");n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(e+" of length "+r+" expected, got "+i);return n}function pe(e){return Uint8Array.from(e)}const ge=e=>"bigint"==typeof e&&ne<=e;function me(e,t,r,n){if(!function(e,t,r){return ge(e)&&ge(t)&&ge(r)&&t<=e&&e<r}(t,r,n))throw new Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function ye(e){let t;for(t=0;e>ne;e>>=ie,t+=1);return t}const be=e=>(ie<<BigInt(e))-ie;function we(e,t,r={}){if(!e||"object"!=typeof e)throw new Error("expected valid options object");function n(t,r,n){const i=e[t];if(n&&void 0===i)return;const s=typeof i;if(s!==r||null===i)throw new Error(`param "${t}" is invalid: expected ${r}, got ${s}`)}Object.entries(t).forEach((([e,t])=>n(e,t,!1))),Object.entries(r).forEach((([e,t])=>n(e,t,!0)))}const Se=()=>{throw new Error("not implemented")};function ke(e){const t=new WeakMap;return(r,...n)=>{const i=t.get(r);if(void 0!==i)return i;const s=e(r,...n);return t.set(r,s),s}}const ve=BigInt(0),Ie=BigInt(1),Be=BigInt(2),Ee=BigInt(3),xe=BigInt(4),Ae=BigInt(5),Oe=BigInt(7),_e=BigInt(8),Te=BigInt(9),Pe=BigInt(16);function je(e,t){const r=e%t;return r>=ve?r:t+r}function Ce(e,t,r){let n=e;for(;t-- >ve;)n*=n,n%=r;return n}function Re(e,t){if(e===ve)throw new Error("invert: expected non-zero number");if(t<=ve)throw new Error("invert: expected positive modulus, got "+t);let r=je(e,t),n=t,i=ve,s=Ie,o=Ie,a=ve;for(;r!==ve;){const e=n/r,t=n%r,c=i-o*e,u=s-a*e;n=r,r=t,i=o,s=a,o=c,a=u}if(n!==Ie)throw new Error("invert: does not exist");return je(i,t)}function ze(e,t,r){if(!e.eql(e.sqr(t),r))throw new Error("Cannot find square root")}function Ne(e,t){const r=(e.ORDER+Ie)/xe,n=e.pow(t,r);return ze(e,n,t),n}function Ue(e,t){const r=(e.ORDER-Ae)/_e,n=e.mul(t,Be),i=e.pow(n,r),s=e.mul(t,i),o=e.mul(e.mul(s,Be),i),a=e.mul(s,e.sub(o,e.ONE));return ze(e,a,t),a}function Me(e){if(e<Ee)throw new Error("sqrt is not defined for small field");let t=e-Ie,r=0;for(;t%Be===ve;)t/=Be,r++;let n=Be;const i=Fe(e);for(;1===$e(i,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return Ne;let s=i.pow(n,t);const o=(t+Ie)/Be;return function(e,n){if(e.is0(n))return n;if(1!==$e(e,n))throw new Error("Cannot find square root");let i=r,a=e.mul(e.ONE,s),c=e.pow(n,t),u=e.pow(n,o);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,r=e.sqr(c);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===i)throw new Error("Cannot find square root");const n=Ie<<BigInt(i-t-1),s=e.pow(a,n);i=t,a=e.sqr(s),c=e.mul(c,a),u=e.mul(u,s)}return u}}function Le(e){return e%xe===Ee?Ne:e%_e===Ae?Ue:e%Pe===Te?function(e){const t=Fe(e),r=Me(e),n=r(t,t.neg(t.ONE)),i=r(t,n),s=r(t,t.neg(n)),o=(e+Oe)/Pe;return(e,t)=>{let r=e.pow(t,o),a=e.mul(r,n);const c=e.mul(r,i),u=e.mul(r,s),l=e.eql(e.sqr(a),t),d=e.eql(e.sqr(c),t);r=e.cmov(r,a,l),a=e.cmov(u,c,d);const h=e.eql(e.sqr(a),t),f=e.cmov(r,a,h);return ze(e,f,t),f}}(e):Me(e)}const qe=(e,t)=>(je(e,t)&Ie)===Ie,We=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ke(e,t,r){if(r<ve)throw new Error("invalid exponent, negatives unsupported");if(r===ve)return e.ONE;if(r===Ie)return t;let n=e.ONE,i=t;for(;r>ve;)r&Ie&&(n=e.mul(n,i)),i=e.sqr(i),r>>=Ie;return n}function De(e,t,r=!1){const n=new Array(t.length).fill(r?e.ZERO:void 0),i=t.reduce(((t,r,i)=>e.is0(r)?t:(n[i]=t,e.mul(t,r))),e.ONE),s=e.inv(i);return t.reduceRight(((t,r,i)=>e.is0(r)?t:(n[i]=e.mul(t,n[i]),e.mul(t,r))),s),n}function $e(e,t){const r=(e.ORDER-Ie)/Be,n=e.pow(t,r),i=e.eql(n,e.ONE),s=e.eql(n,e.ZERO),o=e.eql(n,e.neg(e.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Ve(e,t){void 0!==t&&o(t);const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Fe(e,t,r=!1,n={}){if(e<=ve)throw new Error("invalid field: expected ORDER > 0, got "+e);let i,s,o,a=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(i=e.BITS),e.sqrt&&(s=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(a=e.modFromBytes),o=e.allowedLengths}else"number"==typeof t&&(i=t),n.sqrt&&(s=n.sqrt);const{nBitLength:c,nByteLength:u}=Ve(e,i);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const d=Object.freeze({ORDER:e,isLE:r,BITS:c,BYTES:u,MASK:be(c),ZERO:ve,ONE:Ie,allowedLengths:o,create:t=>je(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return ve<=t&&t<e},is0:e=>e===ve,isValidNot0:e=>!d.is0(e)&&d.isValid(e),isOdd:e=>(e&Ie)===Ie,neg:t=>je(-t,e),eql:(e,t)=>e===t,sqr:t=>je(t*t,e),add:(t,r)=>je(t+r,e),sub:(t,r)=>je(t-r,e),mul:(t,r)=>je(t*r,e),pow:(e,t)=>Ke(d,e,t),div:(t,r)=>je(t*Re(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Re(t,e),sqrt:s||(t=>(l||(l=Le(e)),l(d,t))),toBytes:e=>r?he(e,u):de(e,u),fromBytes:(t,n=!0)=>{if(o){if(!o.includes(t.length)||t.length>u)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);const e=new Uint8Array(u);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+t.length);let i=r?le(t):ue(t);if(a&&(i=je(i,e)),!n&&!d.isValid(i))throw new Error("invalid field element: outside of range 0..ORDER");return i},invertBatch:e=>De(d,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(d)}function He(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Ge(e){const t=He(e);return t+Math.ceil(t/2)}const Je=BigInt(0),Ze=BigInt(1);function Xe(e,t){const r=t.negate();return e?r:t}function Ye(e,t){const r=De(e.Fp,t.map((e=>e.Z)));return t.map(((t,n)=>e.fromAffine(t.toAffine(r[n]))))}function Qe(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function et(e,t){Qe(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:be(e),maxNumber:r,shiftBy:BigInt(e)}}function tt(e,t,r){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=r;let a=Number(e&i),c=e>>o;a>n&&(a-=s,c+=Ze);const u=t*n;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:u}}function rt(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach(((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)}))}function nt(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach(((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)}))}const it=new WeakMap,st=new WeakMap;function ot(e){return st.get(e)||1}function at(e){if(e!==Je)throw new Error("invalid wNAF")}class ct{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>Je;)t&Ze&&(r=r.add(n)),n=n.double(),t>>=Ze;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=et(t,this.bits),i=[];let s=e,o=s;for(let e=0;e<r;e++){o=s,i.push(o);for(let e=1;e<n;e++)o=o.add(s),i.push(o);s=o.double()}return i}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,i=this.BASE;const s=et(e,this.bits);for(let e=0;e<s.windows;e++){const{nextN:o,offset:a,isZero:c,isNeg:u,isNegF:l,offsetF:d}=tt(r,e,s);r=o,c?i=i.add(Xe(l,t[d])):n=n.add(Xe(u,t[a]))}return at(r),{p:n,f:i}}wNAFUnsafe(e,t,r,n=this.ZERO){const i=et(e,this.bits);for(let e=0;e<i.windows&&r!==Je;e++){const{nextN:s,offset:o,isZero:a,isNeg:c}=tt(r,e,i);if(r=s,!a){const e=t[o];n=n.add(c?e.negate():e)}}return at(r),n}getPrecomputes(e,t,r){let n=it.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),it.set(t,n))),n}cached(e,t,r){const n=ot(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const i=ot(e);return 1===i?this._unsafeLadder(e,t,n):this.wNAFUnsafe(i,this.getPrecomputes(i,e,r),t,n)}createCache(e,t){Qe(t,this.bits),st.set(e,t),it.delete(e)}hasCache(e){return 1!==ot(e)}}function ut(e,t,r,n){rt(r,e),nt(n,t);const i=r.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,a=ye(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=be(c),l=new Array(Number(u)+1).fill(o);let d=o;for(let e=Math.floor((t.BITS-1)/c)*c;e>=0;e-=c){l.fill(o);for(let t=0;t<s;t++){const i=n[t],s=Number(i>>BigInt(e)&u);l[s]=l[s].add(r[t])}let t=o;for(let e=l.length-1,r=o;e>0;e--)r=r.add(l[e]),t=t.add(r);if(d=d.add(t),0!==e)for(let e=0;e<c;e++)d=d.double()}return d}function lt(e,t,r){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return function(e){const t=We.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});we(e,t)}(t),t}return Fe(e,{isLE:r})}function dt(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw new Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const r=t[e];if(!("bigint"==typeof r&&r>Je))throw new Error(`CURVE.${e} must be positive bigint`)}const i=lt(t.p,r.Fp,n),s=lt(t.n,r.Fn,n),o=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of o)if(!i.isValid(t[e]))throw new Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:i,Fn:s}}const ht=BigInt(0),ft=BigInt(1),pt=BigInt(2),gt=BigInt(8);class mt{constructor(e){this.ep=e}static fromBytes(e){Se()}static fromHex(e){Se()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return g(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,t){return this.init(this.ep.precompute(e,t))}toRawBytes(){return this.toBytes()}}function yt(e,t,r={}){if("function"!=typeof t)throw new Error('"hash" function param is required');we(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=r,{BASE:i,Fp:o,Fn:a}=e,c=r.randomBytes||B,u=r.adjustScalarBytes||(e=>e),l=r.domain||((e,t,r)=>{if(se(r,"phflag"),t.length||r)throw new Error("Contexts/pre-hash are not supported");return e});function d(e){return a.create(le(e))}function h(e){const{head:r,prefix:n,scalar:s}=function(e){const r=y.secretKey;e=fe("private key",e,r);const n=fe("hashed private key",t(e),2*r),i=u(n.slice(0,r));return{head:i,prefix:n.slice(r,2*r),scalar:d(i)}}(e),o=i.multiply(s),a=o.toBytes();return{head:r,prefix:n,scalar:s,point:o,pointBytes:a}}function f(e){return h(e).pointBytes}function p(e=Uint8Array.of(),...r){const i=k(...r);return d(t(l(i,fe("context",e),!!n)))}const g={zip215:!0};const m=o.BYTES,y={secretKey:m,publicKey:m,signature:2*m,seed:m};function b(e=c(y.seed)){return oe(e,y.seed,"seed")}const w={getExtendedPublicKey:h,randomSecretKey:b,isValidSecretKey:function(e){return s(e)&&e.length===a.BYTES},isValidPublicKey:function(t,r){try{return!!e.fromBytes(t,r)}catch(e){return!1}},toMontgomery(t){const{y:r}=e.fromBytes(t),n=y.publicKey,i=32===n;if(!i&&57!==n)throw new Error("only defined for 25519 and 448");const s=i?o.div(ft+r,ft-r):o.div(r-ft,r+ft);return o.toBytes(s)},toMontgomerySecret(e){const r=y.secretKey;oe(e,r);const n=t(e.subarray(0,r));return u(n).subarray(0,r)},randomPrivateKey:b,precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({keygen:function(e){const t=w.randomSecretKey(e);return{secretKey:t,publicKey:f(t)}},getPublicKey:f,sign:function(e,t,r={}){e=fe("message",e),n&&(e=n(e));const{prefix:s,scalar:o,pointBytes:c}=h(t),u=p(r.context,s,e),l=i.multiply(u).toBytes(),d=p(r.context,l,c,e),f=a.create(u+d*o);if(!a.isValid(f))throw new Error("sign failed: invalid s");return oe(k(l,a.toBytes(f)),y.signature,"result")},verify:function(t,r,s,o=g){const{context:a,zip215:c}=o,u=y.signature;t=fe("signature",t,u),r=fe("message",r),s=fe("publicKey",s,y.publicKey),void 0!==c&&se(c,"zip215"),n&&(r=n(r));const l=u/2,d=t.subarray(0,l),h=le(t.subarray(l,u));let f,m,b;try{f=e.fromBytes(s,c),m=e.fromBytes(d,c),b=i.multiplyUnsafe(h)}catch(e){return!1}if(!c&&f.isSmallOrder())return!1;const w=p(a,m.toBytes(),f.toBytes(),r);return m.add(f.multiplyUnsafe(w)).subtract(b).clearCofactor().is0()},utils:w,Point:e,lengths:y})}function bt(e){const{CURVE:t,curveOpts:r,hash:n,eddsaOpts:i}=function(e){const t={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r={Fp:e.Fp,Fn:Fe(t.n,e.nBitLength,!0),uvRatio:e.uvRatio},n={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:t,curveOpts:r,hash:e.hash,eddsaOpts:n}}(e),s=function(e,t={}){const r=dt("edwards",e,t,t.FpFnLE),{Fp:n,Fn:i}=r;let s=r.CURVE;const{h:o}=s;we(t,{},{uvRatio:"function"});const a=pt<<BigInt(8*i.BYTES)-ft,c=e=>n.create(e),u=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:n.sqrt(n.div(e,t))}}catch(e){return{isValid:!1,value:ht}}});if(!function(e,t,r,n){const i=e.sqr(r),s=e.sqr(n),o=e.add(e.mul(t.a,i),s),a=e.add(e.ONE,e.mul(t.d,e.mul(i,s)));return e.eql(o,a)}(n,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function l(e,t,r=!1){return me("coordinate "+e,t,r?ft:ht,a),t}function d(e){if(!(e instanceof p))throw new Error("ExtendedPoint expected")}const h=ke(((e,t)=>{const{X:r,Y:i,Z:s}=e,o=e.is0();null==t&&(t=o?gt:n.inv(s));const a=c(r*t),u=c(i*t),l=n.mul(s,t);if(o)return{x:ht,y:ft};if(l!==ft)throw new Error("invZ was invalid");return{x:a,y:u}})),f=ke((e=>{const{a:t,d:r}=s;if(e.is0())throw new Error("bad point: ZERO");const{X:n,Y:i,Z:o,T:a}=e,u=c(n*n),l=c(i*i),d=c(o*o),h=c(d*d),f=c(u*t);if(c(d*c(f+l))!==c(h+c(r*c(u*l))))throw new Error("bad point: equation left != right (1)");if(c(n*i)!==c(o*a))throw new Error("bad point: equation left != right (2)");return!0}));class p{constructor(e,t,r,n){this.X=l("x",e),this.Y=l("y",t),this.Z=l("z",r,!0),this.T=l("t",n),Object.freeze(this)}static CURVE(){return s}static fromAffine(e){if(e instanceof p)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};return l("x",t),l("y",r),new p(t,r,ft,c(t*r))}static fromBytes(e,t=!1){const r=n.BYTES,{a:i,d:o}=s;e=pe(oe(e,r,"point")),se(t,"zip215");const l=pe(e),d=e[r-1];l[r-1]=-129&d;const h=le(l),f=t?a:n.ORDER;me("point.y",h,ht,f);const g=c(h*h),m=c(g-ft),y=c(o*g-i);let{isValid:b,value:w}=u(m,y);if(!b)throw new Error("bad point: invalid y coordinate");const S=(w&ft)===ft,k=0!=(128&d);if(!t&&w===ht&&k)throw new Error("bad point: x=0 and x_0=1");return k!==S&&(w=c(-w)),p.fromAffine({x:w,y:h})}static fromHex(e,t=!1){return p.fromBytes(fe("point",e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return m.createCache(this,e),t||this.multiply(pt),this}assertValidity(){f(this)}equals(e){d(e);const{X:t,Y:r,Z:n}=this,{X:i,Y:s,Z:o}=e,a=c(t*o),u=c(i*n),l=c(r*o),h=c(s*n);return a===u&&l===h}is0(){return this.equals(p.ZERO)}negate(){return new p(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:e}=s,{X:t,Y:r,Z:n}=this,i=c(t*t),o=c(r*r),a=c(pt*c(n*n)),u=c(e*i),l=t+r,d=c(c(l*l)-i-o),h=u+o,f=h-a,g=u-o,m=c(d*f),y=c(h*g),b=c(d*g),w=c(f*h);return new p(m,y,w,b)}add(e){d(e);const{a:t,d:r}=s,{X:n,Y:i,Z:o,T:a}=this,{X:u,Y:l,Z:h,T:f}=e,g=c(n*u),m=c(i*l),y=c(a*r*f),b=c(o*h),w=c((n+i)*(u+l)-g-m),S=b-y,k=b+y,v=c(m-t*g),I=c(w*S),B=c(k*v),E=c(w*v),x=c(S*k);return new p(I,B,x,E)}subtract(e){return this.add(e.negate())}multiply(e){if(!i.isValidNot0(e))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:t,f:r}=m.cached(this,e,(e=>Ye(p,e)));return Ye(p,[t,r])[0]}multiplyUnsafe(e,t=p.ZERO){if(!i.isValid(e))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return e===ht?p.ZERO:this.is0()||e===ft?this:m.unsafe(this,e,(e=>Ye(p,e)),t)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return m.unsafe(this,s.n).is0()}toAffine(e){return h(this,e)}clearCofactor(){return o===ft?this:this.multiplyUnsafe(o)}toBytes(){const{x:e,y:t}=this.toAffine(),r=n.toBytes(t);return r[r.length-1]|=e&ft?128:0,r}toHex(){return g(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(e){return Ye(p,e)}static msm(e,t){return ut(p,i,e,t)}_setWindowSize(e){this.precompute(e)}toRawBytes(){return this.toBytes()}}p.BASE=new p(s.Gx,s.Gy,ft,c(s.Gx*s.Gy)),p.ZERO=new p(ht,ft,ft,ht),p.Fp=n,p.Fn=i;const m=new ct(p,i.BITS);return p.BASE.precompute(8),p}(t,r);return function(e,t){const r=t.Point;return Object.assign({},t,{ExtendedPoint:r,CURVE:e,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(e,yt(s,n,i))}w("HashToScalar-");const wt=BigInt(0),St=BigInt(1),kt=BigInt(2),vt=(BigInt(3),BigInt(5)),It=BigInt(8),Bt=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Et=(()=>({p:Bt,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:It,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function xt(e){const t=BigInt(10),r=BigInt(20),n=BigInt(40),i=BigInt(80),s=Bt,o=e*e%s*e%s,a=Ce(o,kt,s)*o%s,c=Ce(a,St,s)*e%s,u=Ce(c,vt,s)*c%s,l=Ce(u,t,s)*u%s,d=Ce(l,r,s)*l%s,h=Ce(d,n,s)*d%s,f=Ce(h,i,s)*h%s,p=Ce(f,i,s)*h%s,g=Ce(p,t,s)*u%s;return{pow_p_5_8:Ce(g,kt,s)*e%s,b2:o}}function At(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Ot=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function _t(e,t){const r=Bt,n=je(t*t*t,r),i=je(n*n*t,r);let s=je(e*n*xt(e*i).pow_p_5_8,r);const o=je(t*s*s,r),a=s,c=je(s*Ot,r),u=o===e,l=o===je(-e,r),d=o===je(-e*Ot,r);return u&&(s=a),(l||d)&&(s=c),qe(s,r)&&(s=je(-s,r)),{isValid:u||l,value:s}}const Tt=(()=>Fe(Et.p,{isLE:!0}))(),Pt=(()=>Fe(Et.n,{isLE:!0}))(),jt=(()=>({...Et,Fp:Tt,hash:re,adjustScalarBytes:At,uvRatio:_t}))(),Ct=(()=>bt(jt))();const Rt=Ot,zt=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),Nt=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),Ut=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Mt=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),Lt=e=>_t(St,e),qt=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Wt=e=>Ct.Point.Fp.create(le(e)&qt);function Kt(e){const{d:t}=Et,r=Bt,n=e=>Tt.create(e),i=n(Rt*e*e),s=n((i+St)*Ut);let o=BigInt(-1);const a=n((o-t*i)*n(i+t));let{isValid:c,value:u}=_t(s,a),l=n(u*e);qe(l,r)||(l=n(-l)),c||(u=l),c||(o=i);const d=n(o*(i-St)*Mt-a),h=u*u,f=n((u+u)*a),p=n(d*zt),g=n(St-h),m=n(St+h);return new Ct.Point(n(f*m),n(g*p),n(p*m),n(f*g))}function Dt(e){a(e,64);const t=Kt(Wt(e.subarray(0,32))),r=Kt(Wt(e.subarray(32,64)));return new $t(t.add(r))}class $t extends mt{constructor(e){super(e)}static fromAffine(e){return new $t(Ct.Point.fromAffine(e))}assertSame(e){if(!(e instanceof $t))throw new Error("RistrettoPoint expected")}init(e){return new $t(e)}static hashToCurve(e){return Dt(fe("ristrettoHash",e,64))}static fromBytes(e){a(e,32);const{a:t,d:r}=Et,n=Bt,i=e=>Tt.create(e),s=Wt(e);if(!function(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r}(Tt.toBytes(s),e)||qe(s,n))throw new Error("invalid ristretto255 encoding 1");const o=i(s*s),c=i(St+t*o),u=i(St-t*o),l=i(c*c),d=i(u*u),h=i(t*r*l-d),{isValid:f,value:p}=Lt(i(h*d)),g=i(p*u),m=i(p*g*h);let y=i((s+s)*g);qe(y,n)&&(y=i(-y));const b=i(c*m),w=i(y*b);if(!f||qe(w,n)||b===wt)throw new Error("invalid ristretto255 encoding 2");return new $t(new Ct.Point(y,b,St,w))}static fromHex(e){return $t.fromBytes(fe("ristrettoHex",e,32))}static msm(e,t){return ut($t,Ct.Point.Fn,e,t)}toBytes(){let{X:e,Y:t,Z:r,T:n}=this.ep;const i=Bt,s=e=>Tt.create(e),o=s(s(r+t)*s(r-t)),a=s(e*t),c=s(a*a),{value:u}=Lt(s(o*c)),l=s(u*o),d=s(u*a),h=s(l*d*n);let f;if(qe(n*h,i)){let r=s(t*Rt),n=s(e*Rt);e=r,t=n,f=s(l*Nt)}else f=d;qe(e*h,i)&&(t=s(-t));let p=s((r-t)*f);return qe(p,i)&&(p=s(-p)),Tt.toBytes(p)}equals(e){this.assertSame(e);const{X:t,Y:r}=this.ep,{X:n,Y:i}=e.ep,s=e=>Tt.create(e),o=s(t*i)===s(r*n),a=s(r*i)===s(t*n);return o||a}is0(){return this.equals($t.ZERO)}}$t.BASE=(()=>new $t(Ct.Point.BASE))(),$t.ZERO=(()=>new $t(Ct.Point.ZERO))(),$t.Fp=(()=>Tt)(),$t.Fn=(()=>Pt)();var Vt=r(1876),Ft=r.n(Vt),Ht=r(91927),Gt=r.n(Ht);function Jt(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Zt(e,...t){if(!((r=e)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Xt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Yt(e,t){Zt(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const Qt=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),er=(e,t)=>e<<32-t|e>>>t,tr=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],rr=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;function nr(e){for(let t=0;t<e.length;t++)e[t]=rr(e[t])}function ir(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Zt(e),e}class sr{clone(){return this._cloneInto()}}function or(e){const t=t=>e().update(ir(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}const ar=(e,t,r)=>e&t^e&r^t&r;class cr extends sr{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Qt(this.buffer)}update(e){Xt(this);const{view:t,buffer:r,blockLen:n}=this,i=(e=ir(e)).length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o!==n)r.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=Qt(e);for(;n<=i-s;s+=n)this.process(t,s)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){Xt(this),Yt(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:i}=this;let{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>n-s&&(this.process(r,0),s=0);for(let e=s;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),a=Number(r&s),c=n?4:0,u=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+u,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const o=Qt(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)o.setUint32(4*e,u[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:i,destroyed:s,pos:o}=this;return e.length=n,e.pos=o,e.finished=i,e.destroyed=s,n%t&&e.buffer.set(r),e}}const ur=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),lr=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),dr=new Uint32Array(64);class hr extends cr{constructor(){super(64,32,8,!1),this.A=0|lr[0],this.B=0|lr[1],this.C=0|lr[2],this.D=0|lr[3],this.E=0|lr[4],this.F=0|lr[5],this.G=0|lr[6],this.H=0|lr[7]}get(){const{A:e,B:t,C:r,D:n,E:i,F:s,G:o,H:a}=this;return[e,t,r,n,i,s,o,a]}set(e,t,r,n,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)dr[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=dr[e-15],r=dr[e-2],n=er(t,7)^er(t,18)^t>>>3,i=er(r,17)^er(r,19)^r>>>10;dr[e]=i+dr[e-7]+n+dr[e-16]|0}let{A:r,B:n,C:i,D:s,E:o,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(er(o,6)^er(o,11)^er(o,25))+((l=o)&a^~l&c)+ur[e]+dr[e]|0,d=(er(r,2)^er(r,13)^er(r,22))+ar(r,n,i)|0;u=c,c=a,a=o,o=s+t|0,s=i,i=n,n=r,r=t+d|0}var l;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,i,s,o,a,c,u)}roundClean(){dr.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const fr=or((()=>new hr));var pr=r(76547),gr=r(45695),mr=r(70508);class yr extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:o}=e,a=0===o.length?n:`At path: ${o.join(".")} -- ${n}`;super(i??a),null!=i&&(this.cause=a),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function br(e){return"object"==typeof e&&null!=e}function wr(e){return br(e)&&!Array.isArray(e)}function Sr(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function kr(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:o}=r,{refinement:a,message:c=`Expected a value of type \`${o}\`${a?` with refinement \`${a}\``:""}, but received: \`${Sr(n)}\``}=e;return{value:n,type:o,refinement:a,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*vr(e,t,r,n){var i;br(i=e)&&"function"==typeof i[Symbol.iterator]||(e=[e]);for(const i of e){const e=kr(i,t,r,n);e&&(yield e)}}function*Ir(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:o=!1}=r,a={path:n,branch:i,mask:o};s&&(e=t.coercer(e,a));let c="valid";for(const n of t.validator(e,a))n.explanation=r.message,c="not_valid",yield[n,void 0];for(let[u,l,d]of t.entries(e,a)){const t=Ir(l,d,{path:void 0===u?n:[...n,u],branch:void 0===u?i:[...i,l],coerce:s,mask:o,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(l=r[1],void 0===u?e=l:e instanceof Map?e.set(u,l):e instanceof Set?e.add(l):br(e)&&(void 0!==l||u in e)&&(e[u]=l))}if("not_valid"!==c)for(const n of t.refiner(e,a))n.explanation=r.message,c="not_refined",yield[n,void 0];"valid"===c&&(yield[void 0,e])}class Br{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=(e=>e),entries:o=function*(){}}=e;this.type=t,this.schema=r,this.entries=o,this.coercer=s,this.validator=n?(e,t)=>vr(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>vr(i(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,r){const n=Ar(e,t,{message:r});if(n[0])throw n[0]}(e,this,t)}create(e,t){return Er(e,this,t)}is(e){return xr(e,this)}mask(e,t){return function(e,t,r){const n=Ar(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}(e,this,t)}validate(e,t={}){return Ar(e,this,t)}}function Er(e,t,r){const n=Ar(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function xr(e,t){return!Ar(e,t)[0]}function Ar(e,t,r={}){const n=Ir(e,t,r),i=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);if(i[0]){return[new yr(i[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]}return[void 0,i[1]]}function Or(e,t){return new Br({type:e,schema:null,validator:t})}function _r(e){return new Br({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${Sr(e)}`})}function Tr(){return Or("boolean",(e=>"boolean"==typeof e))}function Pr(e){return Or("instance",(t=>t instanceof e||`Expected a \`${e.name}\` instance, but received: ${Sr(t)}`))}function jr(e){const t=Sr(e),r=typeof e;return new Br({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${Sr(r)}`})}function Cr(){return Or("never",(()=>!1))}function Rr(e){return new Br({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function zr(){return Or("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${Sr(e)}`))}function Nr(e){return new Br({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function Ur(e,t){return new Br({type:"record",schema:null,*entries(r){if(br(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator:e=>wr(e)||`Expected an object, but received: ${Sr(e)}`,coercer:e=>wr(e)?{...e}:e})}function Mr(){return Or("string",(e=>"string"==typeof e||`Expected a string, but received: ${Sr(e)}`))}function Lr(e){const t=Cr();return new Br({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator:e=>Array.isArray(e)||`Expected an array, but received: ${Sr(e)}`,coercer:e=>Array.isArray(e)?e.slice():e})}function qr(e){const t=Object.keys(e);return new Br({type:"type",schema:e,*entries(r){if(br(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>wr(e)||`Expected an object, but received: ${Sr(e)}`,coercer:e=>wr(e)?{...e}:e})}function Wr(e){const t=e.map((e=>e.type)).join(" | ");return new Br({type:"union",schema:null,coercer(t,r){for(const n of e){const[e,i]=n.validate(t,{coerce:!0,mask:r.mask});if(!e)return i}return t},validator(r,n){const i=[];for(const t of e){const[...e]=Ir(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Sr(r)}`,...i]}})}function Kr(){return Or("unknown",(()=>!0))}function Dr(e,t,r){return new Br({...e,coercer:(n,i)=>xr(n,t)?e.coercer(r(n,i),i):e.coercer(n,i)})}var $r=r(98639),Vr=r.n($r),Fr=r(55838);const Hr=BigInt(2**32-1),Gr=BigInt(32);function Jr(e,t=!1){return t?{h:Number(e&Hr),l:Number(e>>Gr&Hr)}:{h:0|Number(e>>Gr&Hr),l:0|Number(e&Hr)}}function Zr(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:s,l:o}=Jr(e[i],t);[r[i],n[i]]=[s,o]}return[r,n]}const Xr=(e,t,r)=>e<<r|t>>>32-r,Yr=(e,t,r)=>t<<r|e>>>32-r,Qr=(e,t,r)=>t<<r-32|e>>>64-r,en=(e,t,r)=>e<<r-32|t>>>64-r;const tn=[],rn=[],nn=[],sn=BigInt(0),on=BigInt(1),an=BigInt(2),cn=BigInt(7),un=BigInt(256),ln=BigInt(113);for(let e=0,t=on,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],tn.push(2*(5*n+r)),rn.push((e+1)*(e+2)/2%64);let i=sn;for(let e=0;e<7;e++)t=(t<<on^(t>>cn)*ln)%un,t&an&&(i^=on<<(on<<BigInt(e))-on);nn.push(i)}const[dn,hn]=Zr(nn,!0),fn=(e,t,r)=>r>32?Qr(e,t,r):Xr(e,t,r),pn=(e,t,r)=>r>32?en(e,t,r):Yr(e,t,r);class gn extends sr{constructor(e,t,r,n=!1,i=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Jt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){tr||nr(this.state32),function(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const n=(t+8)%10,i=(t+2)%10,s=r[i],o=r[i+1],a=fn(s,o,1)^r[n],c=pn(s,o,1)^r[n+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=c}let t=e[2],i=e[3];for(let r=0;r<24;r++){const n=rn[r],s=fn(t,i,n),o=pn(t,i,n),a=tn[r];t=e[a],i=e[a+1],e[a]=s,e[a+1]=o}for(let t=0;t<50;t+=10){for(let n=0;n<10;n++)r[n]=e[t+n];for(let n=0;n<10;n++)e[t+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=dn[n],e[1]^=hn[n]}r.fill(0)}(this.state32,this.rounds),tr||nr(this.state32),this.posOut=0,this.pos=0}update(e){Xt(this);const{blockLen:t,state:r}=this,n=(e=ir(e)).length;for(let i=0;i<n;){const s=Math.min(t-this.pos,n-i);for(let t=0;t<s;t++)r[this.pos++]^=e[i++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,0!=(128&t)&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){Xt(this,!1),Zt(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,i=e.length;n<i;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,i-n);e.set(t.subarray(this.posOut,this.posOut+s),n),this.posOut+=s,n+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Jt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Yt(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:i,enableXOF:s}=this;return e||(e=new gn(t,r,n,s,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=n,e.enableXOF=s,e.destroyed=this.destroyed,e}}const mn=(e,t,r)=>or((()=>new gn(t,e,r))),yn=mn(1,136,32);class bn extends v{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,c(e);const r=S(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),l(i)}update(e){return u(this),this.iHash.update(e),this}digestInto(e){u(this),a(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:i,blockLen:s,outputLen:o}=this;return e.finished=n,e.destroyed=i,e.blockLen=s,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const wn=(e,t,r)=>new bn(e,t).update(r).digest();wn.create=(e,t)=>new bn(e,t);const Sn=(e,t)=>(e+(e>=0?t:-t)/An)/t;function kn(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function vn(e,t){const r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return se(r.lowS,"lowS"),se(r.prehash,"prehash"),void 0!==r.format&&kn(r.format),r}class In extends Error{constructor(e=""){super(e)}}const Bn={Err:In,_tlv:{encode:(e,t)=>{const{Err:r}=Bn;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");const n=t.length/2,i=ae(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?ae(i.length/2|128):"";return ae(e)+s+i+t},decode(e,t){const{Err:r}=Bn;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const i=t[n++];let s=0;if(!!(128&i)){const e=127&i;if(!e)throw new r("tlv.decode(long): indefinite length not supported");if(e>4)throw new r("tlv.decode(long): byte length is too big");const o=t.subarray(n,n+e);if(o.length!==e)throw new r("tlv.decode: length bytes not complete");if(0===o[0])throw new r("tlv.decode(long): zero leftmost byte");for(const e of o)s=s<<8|e;if(n+=e,s<128)throw new r("tlv.decode(long): not minimal encoding")}else s=i;const o=t.subarray(n,n+s);if(o.length!==s)throw new r("tlv.decode: wrong value length");return{v:o,l:t.subarray(n+s)}}},_int:{encode(e){const{Err:t}=Bn;if(e<En)throw new t("integer: negative integers are not allowed");let r=ae(e);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=Bn;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return ue(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=Bn,i=fe("signature",e),{v:s,l:o}=n.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:u,l}=n.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(u)}},hexFromSig(e){const{_tlv:t,_int:r}=Bn,n=t.encode(2,r.encode(e.r))+t.encode(2,r.encode(e.s));return t.encode(48,n)}},En=BigInt(0),xn=BigInt(1),An=BigInt(2),On=BigInt(3),_n=BigInt(4);function Tn(e,t){const{BYTES:r}=e;let n;if("bigint"==typeof t)n=t;else{let i=fe("private key",t);try{n=e.fromBytes(i)}catch(e){throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!e.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function Pn(e,t={}){const r=dt("weierstrass",e,t),{Fp:n,Fn:i}=r;let s=r.CURVE;const{h:o,n:a}=s;we(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=t;if(c&&(!n.is0(s.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=Cn(n,i);function l(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const d=t.toBytes||function(e,t,r){const{x:i,y:s}=t.toAffine(),o=n.toBytes(i);if(se(r,"isCompressed"),r){l();return k(jn(!n.isOdd(s)),o)}return k(Uint8Array.of(4),o,n.toBytes(s))},h=t.fromBytes||function(e){oe(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:r}=u,i=e.length,s=e[0],o=e.subarray(1);if(i!==t||2!==s&&3!==s){if(i===r&&4===s){const e=n.BYTES,t=n.fromBytes(o.subarray(0,e)),r=n.fromBytes(o.subarray(e,2*e));if(!p(t,r))throw new Error("bad point: is not on curve");return{x:t,y:r}}throw new Error(`bad point: got length ${i}, expected compressed=${t} or uncompressed=${r}`)}{const e=n.fromBytes(o);if(!n.isValid(e))throw new Error("bad point: is not on curve, wrong x");const t=f(e);let r;try{r=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("bad point: is not on curve, sqrt error"+t)}l();return 1==(1&s)!==n.isOdd(r)&&(r=n.neg(r)),{x:e,y:r}}};function f(e){const t=n.sqr(e),r=n.mul(t,e);return n.add(n.add(r,n.mul(e,s.a)),s.b)}function p(e,t){const r=n.sqr(t),i=f(e);return n.eql(r,i)}if(!p(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const m=n.mul(n.pow(s.a,On),_n),y=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(m,y)))throw new Error("bad curve params: a or b");function b(e,t,r=!1){if(!n.isValid(t)||r&&n.is0(t))throw new Error(`bad point coordinate ${e}`);return t}function w(e){if(!(e instanceof E))throw new Error("ProjectivePoint expected")}function S(e){if(!c||!c.basises)throw new Error("no endo");return function(e,t,r){const[[n,i],[s,o]]=t,a=Sn(o*e,r),c=Sn(-i*e,r);let u=e-a*n-c*s,l=-a*i-c*o;const d=u<En,h=l<En;d&&(u=-u),h&&(l=-l);const f=be(Math.ceil(ye(r)/2))+xn;if(u<En||u>=f||l<En||l>=f)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:d,k1:u,k2neg:h,k2:l}}(e,c.basises,i.ORDER)}const v=ke(((e,t)=>{const{X:r,Y:i,Z:s}=e;if(n.eql(s,n.ONE))return{x:r,y:i};const o=e.is0();null==t&&(t=o?n.ONE:n.inv(s));const a=n.mul(r,t),c=n.mul(i,t),u=n.mul(s,t);if(o)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}})),I=ke((e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.Y))return;throw new Error("bad point: ZERO")}const{x:r,y:i}=e.toAffine();if(!n.isValid(r)||!n.isValid(i))throw new Error("bad point: x or y not field elements");if(!p(r,i))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));function B(e,t,r,i,s){return r=new E(n.mul(r.X,e),r.Y,r.Z),t=Xe(i,t),r=Xe(s,r),t.add(r)}class E{constructor(e,t,r){this.X=b("x",e),this.Y=b("y",t,!0),this.Z=b("z",r),Object.freeze(this)}static CURVE(){return s}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof E)throw new Error("projective point not allowed");return n.is0(t)&&n.is0(r)?E.ZERO:new E(t,r,n.ONE)}static fromBytes(e){const t=E.fromAffine(h(oe(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return E.fromBytes(fe("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return A.createCache(this,e),t||this.multiply(On),this}assertValidity(){I(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){w(e);const{X:t,Y:r,Z:i}=this,{X:s,Y:o,Z:a}=e,c=n.eql(n.mul(t,a),n.mul(s,i)),u=n.eql(n.mul(r,a),n.mul(o,i));return c&&u}negate(){return new E(this.X,n.neg(this.Y),this.Z)}double(){const{a:e,b:t}=s,r=n.mul(t,On),{X:i,Y:o,Z:a}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO,d=n.mul(i,i),h=n.mul(o,o),f=n.mul(a,a),p=n.mul(i,o);return p=n.add(p,p),l=n.mul(i,a),l=n.add(l,l),c=n.mul(e,l),u=n.mul(r,f),u=n.add(c,u),c=n.sub(h,u),u=n.add(h,u),u=n.mul(c,u),c=n.mul(p,c),l=n.mul(r,l),f=n.mul(e,f),p=n.sub(d,f),p=n.mul(e,p),p=n.add(p,l),l=n.add(d,d),d=n.add(l,d),d=n.add(d,f),d=n.mul(d,p),u=n.add(u,d),f=n.mul(o,a),f=n.add(f,f),d=n.mul(f,p),c=n.sub(c,d),l=n.mul(f,h),l=n.add(l,l),l=n.add(l,l),new E(c,u,l)}add(e){w(e);const{X:t,Y:r,Z:i}=this,{X:o,Y:a,Z:c}=e;let u=n.ZERO,l=n.ZERO,d=n.ZERO;const h=s.a,f=n.mul(s.b,On);let p=n.mul(t,o),g=n.mul(r,a),m=n.mul(i,c),y=n.add(t,r),b=n.add(o,a);y=n.mul(y,b),b=n.add(p,g),y=n.sub(y,b),b=n.add(t,i);let S=n.add(o,c);return b=n.mul(b,S),S=n.add(p,m),b=n.sub(b,S),S=n.add(r,i),u=n.add(a,c),S=n.mul(S,u),u=n.add(g,m),S=n.sub(S,u),d=n.mul(h,b),u=n.mul(f,m),d=n.add(u,d),u=n.sub(g,d),d=n.add(g,d),l=n.mul(u,d),g=n.add(p,p),g=n.add(g,p),m=n.mul(h,m),b=n.mul(f,b),g=n.add(g,m),m=n.sub(p,m),m=n.mul(h,m),b=n.add(b,m),p=n.mul(g,b),l=n.add(l,p),p=n.mul(S,b),u=n.mul(y,u),u=n.sub(u,p),p=n.mul(y,g),d=n.mul(S,d),d=n.add(d,p),new E(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(E.ZERO)}multiply(e){const{endo:r}=t;if(!i.isValidNot0(e))throw new Error("invalid scalar: out of range");let n,s;const o=e=>A.cached(this,e,(e=>Ye(E,e)));if(r){const{k1neg:t,k1:i,k2neg:a,k2:c}=S(e),{p:u,f:l}=o(i),{p:d,f:h}=o(c);s=l.add(h),n=B(r.beta,u,d,t,a)}else{const{p:t,f:r}=o(e);n=t,s=r}return Ye(E,[n,s])[0]}multiplyUnsafe(e){const{endo:r}=t,n=this;if(!i.isValid(e))throw new Error("invalid scalar: out of range");if(e===En||n.is0())return E.ZERO;if(e===xn)return n;if(A.hasCache(this))return this.multiply(e);if(r){const{k1neg:t,k1:i,k2neg:s,k2:o}=S(e),{p1:a,p2:c}=function(e,t,r,n){let i=t,s=e.ZERO,o=e.ZERO;for(;r>Je||n>Je;)r&Ze&&(s=s.add(i)),n&Ze&&(o=o.add(i)),i=i.double(),r>>=Ze,n>>=Ze;return{p1:s,p2:o}}(E,n,i,o);return B(r.beta,a,c,t,s)}return A.unsafe(n,e)}multiplyAndAddUnsafe(e,t,r){const n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return v(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return o===xn||(e?e(E,this):A.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:e}=t;return o===xn?this:e?e(E,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(e=!0){return se(e,"isCompressed"),this.assertValidity(),d(E,this,e)}toHex(e=!0){return g(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return Ye(E,e)}static msm(e,t){return ut(E,i,e,t)}static fromPrivateKey(e){return E.BASE.multiply(Tn(i,e))}}E.BASE=new E(s.Gx,s.Gy,n.ONE),E.ZERO=new E(n.ZERO,n.ONE,n.ZERO),E.Fp=n,E.Fn=i;const x=i.BITS,A=new ct(E,t.endo?Math.ceil(x/2):x);return E.BASE.precompute(8),E}function jn(e){return Uint8Array.of(e?2:3)}function Cn(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Rn(e,t={}){const{Fn:r}=e,n=t.randomBytes||B,i=Object.assign(Cn(e.Fp,r),{seed:Ge(r.ORDER)});function s(e){try{return!!Tn(r,e)}catch(e){return!1}}function o(e=n(i.seed)){return function(e,t,r=!1){const n=e.length,i=He(t),s=Ge(t);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=je(r?le(e):ue(e),t-Ie)+Ie;return r?he(o,i):de(o,i)}(oe(e,i.seed,"seed"),r.ORDER)}function a(t,n=!0){return e.BASE.multiply(Tn(r,t)).toBytes(n)}function c(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:n,publicKey:s,publicKeyUncompressed:o}=i;if(r.allowedLengths||n===s)return;const a=fe("key",t).length;return a===s||a===o}const u={isValidSecretKey:s,isValidPublicKey:function(t,r){const{publicKey:n,publicKeyUncompressed:s}=i;try{const i=t.length;return(!0!==r||i===n)&&((!1!==r||i===s)&&!!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:o,isValidPrivateKey:s,randomPrivateKey:o,normPrivateKeyToScalar:e=>Tn(r,e),precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({getPublicKey:a,getSharedSecret:function(t,n,i=!0){if(!0===c(t))throw new Error("first arg must be private key");if(!1===c(n))throw new Error("second arg must be public key");const s=Tn(r,t);return e.fromHex(n).multiply(s).toBytes(i)},keygen:function(e){const t=o(e);return{secretKey:t,publicKey:a(t)}},Point:e,utils:u,lengths:i})}function zn(e,t,r={}){c(t),we(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||B,i=r.hmac||((e,...r)=>wn(t,e,k(...r))),{Fp:o,Fn:a}=e,{ORDER:u,BITS:l}=a,{keygen:d,getPublicKey:h,getSharedSecret:f,utils:p,lengths:m}=Rn(e,r),y={prehash:!1,lowS:"boolean"==typeof r.lowS&&r.lowS,format:void 0,extraEntropy:!1},w="compact";function S(e){return e>u>>xn}function v(e,t){if(!a.isValidNot0(t))throw new Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class I{constructor(e,t,r){this.r=v("r",e),this.s=v("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,t=w){let r;if(function(e,t){kn(t);const r=m.signature;oe(e,"compact"===t?r:"recovered"===t?r+1:void 0,`${t} signature`)}(e,t),"der"===t){const{r:t,s:r}=Bn.toSig(oe(e));return new I(t,r)}"recovered"===t&&(r=e[0],t="compact",e=e.subarray(1));const n=a.BYTES,i=e.subarray(0,n),s=e.subarray(n,2*n);return new I(a.fromBytes(i),a.fromBytes(s),r)}static fromHex(e,t){return this.fromBytes(b(e),t)}addRecoveryBit(e){return new I(this.r,this.s,e)}recoverPublicKey(t){const r=o.ORDER,{r:n,s:i,recovery:s}=this;if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");if(u*An<r&&s>1)throw new Error("recovery id is ambiguous for h>1 curve");const c=2===s||3===s?n+u:n;if(!o.isValid(c))throw new Error("recovery id 2 or 3 invalid");const l=o.toBytes(c),d=e.fromBytes(k(jn(0==(1&s)),l)),h=a.inv(c),f=x(fe("msgHash",t)),p=a.create(-f*h),g=a.create(i*h),m=e.BASE.multiplyUnsafe(p).add(d.multiplyUnsafe(g));if(m.is0())throw new Error("point at infinify");return m.assertValidity(),m}hasHighS(){return S(this.s)}toBytes(e=w){if(kn(e),"der"===e)return b(Bn.hexFromSig(this));const t=a.toBytes(this.r),r=a.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw new Error("recovery bit must be present");return k(Uint8Array.of(this.recovery),t,r)}return k(t,r)}toHex(e){return g(this.toBytes(e))}assertValidity(){}static fromCompact(e){return I.fromBytes(fe("sig",e),"compact")}static fromDER(e){return I.fromBytes(fe("sig",e),"der")}normalizeS(){return this.hasHighS()?new I(this.r,a.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return g(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return g(this.toBytes("compact"))}}const E=r.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=ue(e),r=8*e.length-l;return r>0?t>>BigInt(r):t},x=r.bits2int_modN||function(e){return a.create(E(e))},A=be(l);function O(e){return me("num < 2^"+l,e,En,A),a.toBytes(e)}function _(e,r){return oe(e,void 0,"message"),r?oe(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:d,getPublicKey:h,getSharedSecret:f,utils:p,lengths:m,Point:e,sign:function(r,s,o={}){r=fe("message",r);const{seed:c,k2sig:u}=function(t,r,i){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{lowS:s,prehash:o,extraEntropy:c}=vn(i,y);t=_(t,o);const u=x(t),l=Tn(a,r),d=[O(l),O(u)];if(null!=c&&!1!==c){const e=!0===c?n(m.secretKey):c;d.push(fe("extraEntropy",e))}const h=k(...d),f=u;return{seed:h,k2sig:function(t){const r=E(t);if(!a.isValidNot0(r))return;const n=a.inv(r),i=e.BASE.multiply(r).toAffine(),o=a.create(i.x);if(o===En)return;const c=a.create(n*a.create(f+o*l));if(c===En)return;let u=(i.x===o?0:2)|Number(i.y&xn),d=c;return s&&S(c)&&(d=a.neg(c),u^=1),new I(o,d,u)}}}(r,s,o),l=function(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");const n=e=>new Uint8Array(e),i=e=>Uint8Array.of(e);let s=n(e),o=n(e),a=0;const c=()=>{s.fill(1),o.fill(0),a=0},u=(...e)=>r(o,s,...e),l=(e=n(0))=>{o=u(i(0),e),s=u(),0!==e.length&&(o=u(i(1),e),s=u())},d=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){s=u();const t=s.slice();r.push(t),e+=s.length}return k(...r)};return(e,t)=>{let r;for(c(),l(e);!(r=t(d()));)l();return c(),r}}(t.outputLen,a.BYTES,i);return l(c,u)},verify:function(t,r,n,i={}){const{lowS:o,prehash:c,format:u}=vn(i,y);if(n=fe("publicKey",n),r=_(fe("message",r),c),"strict"in i)throw new Error("options.strict was renamed to lowS");const l=void 0===u?function(e){let t;const r="string"==typeof e||s(e),n=!r&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!r&&!n)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(n)t=new I(e.r,e.s);else if(r){try{t=I.fromBytes(fe("sig",e),"der")}catch(e){if(!(e instanceof Bn.Err))throw e}if(!t)try{t=I.fromBytes(fe("sig",e),"compact")}catch(e){return!1}}return t||!1}(t):I.fromBytes(fe("sig",t),u);if(!1===l)return!1;try{const t=e.fromBytes(n);if(o&&l.hasHighS())return!1;const{r:i,s}=l,c=x(r),u=a.inv(s),d=a.create(c*u),h=a.create(i*u),f=e.BASE.multiplyUnsafe(d).add(t.multiplyUnsafe(h));if(f.is0())return!1;return a.create(f.x)===i}catch(e){return!1}},recoverPublicKey:function(e,t,r={}){const{prehash:n}=vn(r,y);return t=_(t,n),I.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:I,hash:t})}function Nn(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map((e=>Math.ceil(e/2))))):void 0;return{CURVE:t,curveOpts:{Fp:r,Fn:Fe(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}function Un(e){const{CURVE:t,curveOpts:r,hash:n,ecdsaOpts:i}=function(e){const{CURVE:t,curveOpts:r}=Nn(e),n={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:r,hash:e.hash,ecdsaOpts:n}}(e);return function(e,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},e,Ve(r.Fn.ORDER,r.Fn.BITS))})}(e,zn(Pn(t,r),n,i))}const Mn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Ln={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},qn=BigInt(2);const Wn=Fe(Mn.p,{sqrt:function(e){const t=Mn.p,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,l=u*u*e%t,d=Ce(l,r,t)*l%t,h=Ce(d,r,t)*l%t,f=Ce(h,qn,t)*u%t,p=Ce(f,i,t)*f%t,g=Ce(p,s,t)*p%t,m=Ce(g,a,t)*g%t,y=Ce(m,c,t)*m%t,b=Ce(y,a,t)*g%t,w=Ce(b,r,t)*l%t,S=Ce(w,o,t)*p%t,k=Ce(S,n,t)*u%t,v=Ce(k,qn,t);if(!Wn.eql(Wn.sqr(v),e))throw new Error("Cannot find square root");return v}}),Kn=function(e,t){const r=t=>Un({...e,hash:t});return{...r(t),create:r}}({...Mn,Fp:Wn,lowS:!0,endo:Ln},te);Ct.utils.randomPrivateKey;const Dn=()=>{const e=Ct.utils.randomPrivateKey(),t=$n(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},$n=Ct.getPublicKey;function Vn(e){try{return Ct.ExtendedPoint.fromHex(e),!0}catch{return!1}}const Fn=(e,t)=>Ct.sign(e,t.slice(0,32)),Hn=Ct.verify,Gn=e=>n.Buffer.isBuffer(e)?e:e instanceof Uint8Array?n.Buffer.from(e.buffer,e.byteOffset,e.byteLength):n.Buffer.from(e);class Jn{constructor(e){Object.assign(this,e)}encode(){return n.Buffer.from((0,pr.serialize)(Zn,this))}static decode(e){return(0,pr.deserialize)(Zn,this,e)}static decodeUnchecked(e){return(0,pr.deserializeUnchecked)(Zn,this,e)}}const Zn=new Map;var Xn;const Yn=32;let Qn=1;class ei extends Jn{constructor(e){if(super({}),this._bn=void 0,function(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const t=Gt().decode(e);if(t.length!=Yn)throw new Error("Invalid public key input");this._bn=new(Ft())(t)}else this._bn=new(Ft())(e);if(this._bn.byteLength()>Yn)throw new Error("Invalid public key input")}}static unique(){const e=new ei(Qn);return Qn+=1,new ei(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Gt().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(n.Buffer);if(e.length===Yn)return e;const t=n.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const i=n.Buffer.concat([e.toBuffer(),n.Buffer.from(t),r.toBuffer()]),s=fr(i);return new ei(s)}static createProgramAddressSync(e,t){let r=n.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");r=n.Buffer.concat([r,Gn(e)])})),r=n.Buffer.concat([r,t.toBuffer(),n.Buffer.from("ProgramDerivedAddress")]);const i=fr(r);if(Vn(i))throw new Error("Invalid seeds, address must fall off the curve");return new ei(i)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,i=255;for(;0!=i;){try{const s=e.concat(n.Buffer.from([i]));r=this.createProgramAddressSync(s,t)}catch(e){if(e instanceof TypeError)throw e;i--;continue}return[r,i]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return Vn(new ei(e).toBytes())}}Xn=ei,ei.default=new Xn("11111111111111111111111111111111"),Zn.set(ei,{kind:"struct",fields:[["_bn","u256"]]});new ei("BPFLoader1111111111111111111111111111111111");const ti=1232;class ri extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ri.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class ni extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ni.prototype,"name",{value:"TransactionExpiredTimeoutError"});class ii extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ii.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class si{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach(((e,r)=>{t.set(e.toBase58(),r)}));const r=e=>{const r=t.get(e.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return e.map((e=>({programIdIndex:r(e.programId),accountKeyIndexes:e.keys.map((e=>r(e.pubkey))),data:e.data})))}}const oi=(e="publicKey")=>gr.Ik(32,e),ai=(e="string")=>{const t=gr.n_([gr.Jq("length"),gr.Jq("lengthPadding"),gr.Ik(gr.cv(gr.Jq(),-8),"chars")],e),r=t.decode.bind(t),i=t.encode.bind(t),s=t;return s.decode=(e,t)=>r(e,t).chars.toString(),s.encode=(e,t,r)=>{const s={chars:n.Buffer.from(e,"utf8")};return i(s,t,r)},s.alloc=e=>gr.Jq().span+gr.Jq().span+n.Buffer.from(e,"utf8").length,s};function ci(e,t){const r=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const n=t[e.property];if(Array.isArray(n))return n.length*r(e.elementLayout)}else if("fields"in e)return ci({layout:e},t[e.property]);return 0};let n=0;return e.layout.fields.forEach((e=>{n+=r(e)})),n}function ui(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0==(128&n))break}return t}function li(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function di(e,t){if(!e)throw new Error(t||"Assertion failed")}class hi{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},i=n(t);i.isSigner=!0,i.isWritable=!0;for(const t of e){n(t.programId).isInvoked=!0;for(const e of t.keys){const t=n(e.pubkey);t.isSigner||=e.isSigner,t.isWritable||=e.isWritable}}return new hi(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];di(e.length<=256,"Max static account keys length exceeded");const t=e.filter((([,e])=>e.isSigner&&e.isWritable)),r=e.filter((([,e])=>e.isSigner&&!e.isWritable)),n=e.filter((([,e])=>!e.isSigner&&e.isWritable)),i=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),s={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{di(t.length>0,"Expected at least one writable signer key");const[e]=t[0];di(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[s,[...t.map((([e])=>new ei(e))),...r.map((([e])=>new ei(e))),...n.map((([e])=>new ei(e))),...i.map((([e])=>new ei(e)))]]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[n,i]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new ei(i),s=e.findIndex((e=>e.equals(t)));s>=0&&(di(s<256,"Max lookup table index exceeded"),r.push(s),n.push(t),this.keyMetaMap.delete(i))}return[r,n]}}const fi="Reached end of buffer unexpectedly";function pi(e){if(0===e.length)throw new Error(fi);return e.shift()}function gi(e,...t){const[r]=t;if(2===t.length?r+(t[1]??0)>e.length:r>=e.length)throw new Error(fi);return e.splice(...t)}class mi{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new ei(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Gt().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new si(this.staticAccountKeys)}static compile(e){const t=hi.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new si(n).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:Gt().encode(e.data)})));return new mi({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-t<this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];li(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,i=Array.from(Gt().decode(e.data));let s=[];li(s,t.length);let o=[];return li(o,i.length),{programIdIndex:r,keyIndicesCount:n.Buffer.from(s),keyIndices:t,dataLength:n.Buffer.from(o),data:i}}));let i=[];li(i,r.length);let s=n.Buffer.alloc(ti);n.Buffer.from(i).copy(s);let o=i.length;r.forEach((e=>{const t=gr.n_([gr.u8("programIdIndex"),gr.Ik(e.keyIndicesCount.length,"keyIndicesCount"),gr.A9(gr.u8("keyIndex"),e.keyIndices.length,"keyIndices"),gr.Ik(e.dataLength.length,"dataLength"),gr.A9(gr.u8("userdatum"),e.data.length,"data")]).encode(e,s,o);o+=t})),s=s.slice(0,o);const a=gr.n_([gr.Ik(1,"numRequiredSignatures"),gr.Ik(1,"numReadonlySignedAccounts"),gr.Ik(1,"numReadonlyUnsignedAccounts"),gr.Ik(t.length,"keyCount"),gr.A9(oi("key"),e,"keys"),oi("recentBlockhash")]),c={numRequiredSignatures:n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:n.Buffer.from(t),keys:this.accountKeys.map((e=>Gn(e.toBytes()))),recentBlockhash:Gt().decode(this.recentBlockhash)};let u=n.Buffer.alloc(2048);const l=a.encode(c,u);return s.copy(u,l),u.slice(0,l+s.length)}static from(e){let t=[...e];const r=pi(t);if(r!==(127&r))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=pi(t),s=pi(t),o=ui(t);let a=[];for(let e=0;e<o;e++){const e=gi(t,0,Yn);a.push(new ei(n.Buffer.from(e)))}const c=gi(t,0,Yn),u=ui(t);let l=[];for(let e=0;e<u;e++){const e=pi(t),r=gi(t,0,ui(t)),i=gi(t,0,ui(t)),s=Gt().encode(n.Buffer.from(i));l.push({programIdIndex:e,accounts:r,data:s})}const d={header:{numRequiredSignatures:r,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:Gt().encode(n.Buffer.from(c)),accountKeys:a,instructions:l};return new mi(d)}}class yi{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new si(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){return e-r<this.addressTableLookups.reduce(((e,t)=>e+t.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-t<r-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find((e=>e.key.equals(r.accountKey)));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=hi.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const e of i){const i=t.extractTableLookup(e);if(void 0!==i){const[e,{writable:t,readonly:s}]=i;r.push(e),n.writable.push(...t),n.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new si(o,n).compileInstructions(e.instructions);return new yi({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:a,addressTableLookups:r})}serialize(){const e=Array();li(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();li(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),i=Array();li(i,this.addressTableLookups.length);const s=gr.n_([gr.u8("prefix"),gr.n_([gr.u8("numRequiredSignatures"),gr.u8("numReadonlySignedAccounts"),gr.u8("numReadonlyUnsignedAccounts")],"header"),gr.Ik(e.length,"staticAccountKeysLength"),gr.A9(oi(),this.staticAccountKeys.length,"staticAccountKeys"),oi("recentBlockhash"),gr.Ik(r.length,"instructionsLength"),gr.Ik(t.length,"serializedInstructions"),gr.Ik(i.length,"addressTableLookupsLength"),gr.Ik(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(ti),a=s.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:Gt().decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:n},o);return o.slice(0,a)}serializeInstructions(){let e=0;const t=new Uint8Array(ti);for(const r of this.compiledInstructions){const n=Array();li(n,r.accountKeyIndexes.length);const i=Array();li(i,r.data.length);e+=gr.n_([gr.u8("programIdIndex"),gr.Ik(n.length,"encodedAccountKeyIndexesLength"),gr.A9(gr.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),gr.Ik(i.length,"encodedDataLength"),gr.Ik(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(ti);for(const r of this.addressTableLookups){const n=Array();li(n,r.writableIndexes.length);const i=Array();li(i,r.readonlyIndexes.length);e+=gr.n_([oi("accountKey"),gr.Ik(n.length,"encodedWritableIndexesLength"),gr.A9(gr.u8(),r.writableIndexes.length,"writableIndexes"),gr.Ik(i.length,"encodedReadonlyIndexesLength"),gr.A9(gr.u8(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=pi(t),n=127&r;di(r!==n,"Expected versioned message but received legacy message");di(0===n,`Expected versioned message with version 0 but found version ${n}`);const i={numRequiredSignatures:pi(t),numReadonlySignedAccounts:pi(t),numReadonlyUnsignedAccounts:pi(t)},s=[],o=ui(t);for(let e=0;e<o;e++)s.push(new ei(gi(t,0,Yn)));const a=Gt().encode(gi(t,0,Yn)),c=ui(t),u=[];for(let e=0;e<c;e++){const e=pi(t),r=gi(t,0,ui(t)),n=ui(t),i=new Uint8Array(gi(t,0,n));u.push({programIdIndex:e,accountKeyIndexes:r,data:i})}const l=ui(t),d=[];for(let e=0;e<l;e++){const e=new ei(gi(t,0,Yn)),r=gi(t,0,ui(t)),n=gi(t,0,ui(t));d.push({accountKey:e,writableIndexes:r,readonlyIndexes:n})}return new yi({header:i,staticAccountKeys:s,recentBlockhash:a,compiledInstructions:u,addressTableLookups:d})}}let bi=function(e){return e[e.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",e[e.PROCESSED=1]="PROCESSED",e[e.TIMED_OUT=2]="TIMED_OUT",e[e.NONCE_INVALID=3]="NONCE_INVALID",e}({});const wi=n.Buffer.alloc(64).fill(0);class Si{constructor(e){this.keys=void 0,this.programId=void 0,this.data=n.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class ki{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Si(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let e=0;e<t.length;e++)if(void 0===t[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const n=[],i=[];t.forEach((e=>{e.keys.forEach((e=>{i.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{i.push({pubkey:new ei(e),isSigner:!1,isWritable:!1})}));const s=[];i.forEach((e=>{const t=e.pubkey.toString(),r=s.findIndex((e=>e.pubkey.toString()===t));r>-1?(s[r].isWritable=s[r].isWritable||e.isWritable,s[r].isSigner=s[r].isSigner||e.isSigner):s.push(e)})),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const o=s.findIndex((e=>e.pubkey.equals(r)));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const e of this.signatures){const t=s.findIndex((t=>t.pubkey.equals(e.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);s[t].isSigner||(s[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,c=0,u=0;const l=[],d=[];s.forEach((({pubkey:e,isSigner:t,isWritable:r})=>{t?(l.push(e.toString()),a+=1,r||(c+=1)):(d.push(e.toString()),r||(u+=1))}));const h=l.concat(d),f=t.map((e=>{const{data:t,programId:r}=e;return{programIdIndex:h.indexOf(r.toString()),accounts:e.keys.map((e=>h.indexOf(e.pubkey.toString()))),data:Gt().encode(t)}}));return f.forEach((e=>{di(e.programIdIndex>=0),e.accounts.forEach((e=>di(e>=0)))})),new mi({header:{numRequiredSignatures:a,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},accountKeys:h,recentBlockhash:e,instructions:f})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter((e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}this.signatures=r.map((e=>({signature:null,publicKey:e.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach((e=>{const t=Fn(r,e.secretKey);this._addSignature(e.publicKey,Gn(t))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){di(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=n.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:i}of this.signatures)null===n?t&&(r.missing||=[]).push(i):Hn(n,e,i.toBytes())||(r.invalid||=[]).push(i);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];li(r,t.length);const i=r.length+64*t.length+e.length,s=n.Buffer.alloc(i);return di(t.length<256),n.Buffer.from(r).copy(s,0),t.forEach((({signature:e},t)=>{null!==e&&(di(64===e.length,"signature has invalid length"),n.Buffer.from(e).copy(s,r.length+64*t))})),e.copy(s,r.length+64*t.length),di(s.length<=ti,`Transaction too large: ${s.length} > 1232`),s}get keys(){return di(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return di(1===this.instructions.length),this.instructions[0].programId}get data(){return di(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=ui(t);let i=[];for(let e=0;e<r;e++){const e=gi(t,0,64);i.push(Gt().encode(n.Buffer.from(e)))}return ki.populate(mi.from(t),i)}static populate(e,t=[]){const r=new ki;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const i={signature:t==Gt().encode(wi)?null:Gt().decode(t),publicKey:e.accountKeys[n]};r.signatures.push(i)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new Si({keys:n,programId:e.accountKeys[t.programIdIndex],data:Gt().decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}const vi=new ei("SysvarC1ock11111111111111111111111111111111"),Ii=(new ei("SysvarEpochSchedu1e111111111111111111111111"),new ei("Sysvar1nstructions1111111111111111111111111"),new ei("SysvarRecentB1ockHashes11111111111111111111")),Bi=new ei("SysvarRent111111111111111111111111111111111"),Ei=(new ei("SysvarRewards111111111111111111111111111111"),new ei("SysvarS1otHashes111111111111111111111111111"),new ei("SysvarS1otHistory11111111111111111111111111"),new ei("SysvarStakeHistory1111111111111111111111111"));class xi extends Error{constructor({action:e,signature:t,transactionMessage:r,logs:n}){const i=n?`Logs: \n${JSON.stringify(n.slice(-10),null,2)}. `:"",s="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let o;switch(e){case"send":o=`Transaction ${t} resulted in an error. \n${r}. `+i+s;break;case"simulate":o=`Simulation failed. \nMessage: ${r}. \n`+i+s;break;default:o=`Unknown action '${e}'`}super(o),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=r,this.transactionLogs=n||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(null==e||"object"!=typeof e||!("then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise(((t,r)=>{e.getTransaction(this.signature).then((e=>{if(e&&e.meta&&e.meta.logMessages){const r=e.meta.logMessages;this.transactionLogs=r,t(r)}else r(new Error("Log messages not found"))})).catch(r)}))),await this.transactionLogs}}class Ai extends Error{constructor({code:e,message:t,data:r},n){super(null!=n?`${n}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}async function Oi(e,t,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await e.sendTransaction(t,r,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:n?.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,i=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else null!=n?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await e.confirmTransaction(s,n&&n.commitment)).value;if(o.err){if(null!=s)throw new xi({action:"send",signature:s,transactionMessage:`Status: (${JSON.stringify(o)})`});throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`)}return s}function _i(e){return new Promise((t=>setTimeout(t,e)))}function Ti(e,t){const r=e.layout.span>=0?e.layout.span:ci(e,t),i=n.Buffer.alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,i),i}const Pi=gr._O("lamportsPerSignature"),ji=gr.n_([gr.Jq("version"),gr.Jq("state"),oi("authorizedPubkey"),oi("nonce"),gr.n_([Pi],"feeCalculator")]),Ci=ji.span;class Ri{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=ji.decode(Gn(e),0);return new Ri({authorizedPubkey:new ei(t.authorizedPubkey),nonce:new ei(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const zi=(Ni=8,e=>{const t=(0,gr.Ik)(Ni,e),{encode:r,decode:i}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),s=t;return s.decode=(e,t)=>{const r=i(e,t);return(0,mr.oU)(n.Buffer.from(r))},s.encode=(e,t,n)=>{const i=(0,mr.k$)(e,Ni);return r(i,t,n)},s});var Ni;const Ui=Object.freeze({Create:{index:0,layout:gr.n_([gr.Jq("instruction"),gr.gM("lamports"),gr.gM("space"),oi("programId")])},Assign:{index:1,layout:gr.n_([gr.Jq("instruction"),oi("programId")])},Transfer:{index:2,layout:gr.n_([gr.Jq("instruction"),zi("lamports")])},CreateWithSeed:{index:3,layout:gr.n_([gr.Jq("instruction"),oi("base"),ai("seed"),gr.gM("lamports"),gr.gM("space"),oi("programId")])},AdvanceNonceAccount:{index:4,layout:gr.n_([gr.Jq("instruction")])},WithdrawNonceAccount:{index:5,layout:gr.n_([gr.Jq("instruction"),gr.gM("lamports")])},InitializeNonceAccount:{index:6,layout:gr.n_([gr.Jq("instruction"),oi("authorized")])},AuthorizeNonceAccount:{index:7,layout:gr.n_([gr.Jq("instruction"),oi("authorized")])},Allocate:{index:8,layout:gr.n_([gr.Jq("instruction"),gr.gM("space")])},AllocateWithSeed:{index:9,layout:gr.n_([gr.Jq("instruction"),oi("base"),ai("seed"),gr.gM("space"),oi("programId")])},AssignWithSeed:{index:10,layout:gr.n_([gr.Jq("instruction"),oi("base"),ai("seed"),oi("programId")])},TransferWithSeed:{index:11,layout:gr.n_([gr.Jq("instruction"),zi("lamports"),ai("seed"),oi("programId")])},UpgradeNonceAccount:{index:12,layout:gr.n_([gr.Jq("instruction")])}});class Mi{constructor(){}static createAccount(e){const t=Ti(Ui.Create,{lamports:e.lamports,space:e.space,programId:Gn(e.programId.toBuffer())});return new Si({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;if("basePubkey"in e){t=Ti(Ui.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:Gn(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{t=Ti(Ui.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Si({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){t=Ti(Ui.AssignWithSeed,{base:Gn(e.basePubkey.toBuffer()),seed:e.seed,programId:Gn(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=Ti(Ui.Assign,{programId:Gn(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Si({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Ti(Ui.CreateWithSeed,{base:Gn(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:Gn(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Si({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){const t=new ki;"basePubkey"in e&&"seed"in e?t.add(Mi.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ci,programId:this.programId})):t.add(Mi.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ci,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=Ti(Ui.InitializeNonceAccount,{authorized:Gn(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Bi,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new Si(r)}static nonceAdvance(e){const t=Ti(Ui.AdvanceNonceAccount),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new Si(r)}static nonceWithdraw(e){const t=Ti(Ui.WithdrawNonceAccount,{lamports:e.lamports});return new Si({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Bi,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const t=Ti(Ui.AuthorizeNonceAccount,{authorized:Gn(e.newAuthorizedPubkey.toBuffer())});return new Si({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;if("basePubkey"in e){t=Ti(Ui.AllocateWithSeed,{base:Gn(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:Gn(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=Ti(Ui.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Si({keys:r,programId:this.programId,data:t})}}Mi.programId=new ei("11111111111111111111111111111111");class Li{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Li.chunkSize)+1+1)}static async load(e,t,r,i,s){{const n=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==s.length&&(a=a||new ki,a.add(Mi.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(i)||(a=a||new ki,a.add(Mi.assign({accountPubkey:r.publicKey,programId:i}))),o.lamports<n&&(a=a||new ki,a.add(Mi.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:n-o.lamports})))}else a=(new ki).add(Mi.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:n>0?n:1,space:s.length,programId:i}));null!==a&&await Oi(e,a,[t,r],{commitment:"confirmed"})}const o=gr.n_([gr.Jq("instruction"),gr.Jq("offset"),gr.Jq("bytesLength"),gr.Jq("bytesLengthPadding"),gr.A9(gr.u8("byte"),gr.cv(gr.Jq(),-8),"bytes")]),a=Li.chunkSize;let c=0,u=s,l=[];for(;u.length>0;){const s=u.slice(0,a),d=n.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new ki).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:d});if(l.push(Oi(e,h,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await _i(1e3/e)}c+=a,u=u.slice(a)}await Promise.all(l);{const s=gr.n_([gr.Jq("instruction")]),o=n.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new ki).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Bi,isSigner:!1,isWritable:!1}],programId:i,data:o}),c="processed",u=await e.sendTransaction(a,[t,r],{preflightCommitment:c}),{context:l,value:d}=await e.confirmTransaction({signature:u,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},c);if(d.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(d)})`);for(;;){try{if(await e.getSlot({commitment:c})>l.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Li.chunkSize=932;new ei("BPFLoader2111111111111111111111111111111111");function qi(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Wi,Ki;function Di(){if(Ki)return Wi;Ki=1;var e=Object.prototype.toString,t=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};function r(n,i){var s,o,a,c,u,l,d;if(!0===n)return"true";if(!1===n)return"false";switch(typeof n){case"object":if(null===n)return null;if(n.toJSON&&"function"==typeof n.toJSON)return r(n.toJSON(),i);if("[object Array]"===(d=e.call(n))){for(a="[",o=n.length-1,s=0;s<o;s++)a+=r(n[s],!0)+",";return o>-1&&(a+=r(n[s],!0)),a+"]"}if("[object Object]"===d){for(o=(c=t(n).sort()).length,a="",s=0;s<o;)void 0!==(l=r(n[u=c[s]],!1))&&(a&&(a+=","),a+=JSON.stringify(u)+":"+l),s++;return"{"+a+"}"}return JSON.stringify(n);case"function":case"undefined":return i?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return Wi=function(e){var t=r(e,!1);if(void 0!==t)return""+t}}var $i=qi(Di());function Vi(e){let t=0;for(;e>1;)e/=2,t++;return t}class Fi{constructor(e,t,r,n,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=i}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const r=Vi(0===(t=e+32+1)?1:(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,1+(t|=t>>32)))-Vi(32)-1;return[r,e-(this.getSlotsInEpoch(r)-32)]}{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch);return[this.firstNormalEpoch+r,t%this.slotsPerEpoch]}var t}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?32*(Math.pow(2,e)-1):(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Vi(32)):this.slotsPerEpoch}}var Hi=globalThis.fetch;class Gi extends Fr.Ey{constructor(e,t,r){super((e=>{const r=(0,Fr.XY)(e,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return this.underlyingSocket="socket"in r?r.socket:r,r}),e,t,r),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return 1===t?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return 1===t?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}class Ji{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=function(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}(Zi,e),r=e.length-56;di(r>=0,"lookup table is invalid"),di(r%32==0,"lookup table is invalid");const n=r/32,{addresses:i}=gr.n_([gr.A9(oi(),n,"addresses")]).decode(e.slice(56));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new ei(t.authority[0]):void 0,addresses:i.map((e=>new ei(e)))}}}const Zi={index:1,layout:gr.n_([gr.Jq("typeIndex"),zi("deactivationSlot"),gr._O("lastExtendedSlot"),gr.u8("lastExtendedStartIndex"),gr.u8(),gr.A9(oi(),gr.cv(gr.u8(),-1),"authority")])},Xi=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;const Yi=Dr(Pr(ei),Mr(),(e=>new ei(e))),Qi=Lr([Mr(),jr("base64")]),es=Dr(Pr(n.Buffer),Qi,(e=>n.Buffer.from(e[0],"base64")));function ts(e){let t,r;if("string"==typeof e)t=e;else if(e){const{commitment:n,...i}=e;t=n,r=i}return{commitment:t,config:r}}function rs(e){return e.map((e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e))}function ns(e){return Wr([qr({jsonrpc:jr("2.0"),id:Mr(),result:e}),qr({jsonrpc:jr("2.0"),id:Mr(),error:qr({code:Kr(),message:Mr(),data:Nr(Or("any",(()=>!0)))})})])}const is=ns(Kr());function ss(e){return Dr(ns(e),is,(t=>"error"in t?t:{...t,result:Er(t.result,e)}))}function os(e){return ss(qr({context:qr({slot:zr()}),value:e}))}function as(e){return qr({context:qr({slot:zr()}),value:e})}function cs(e,t){return 0===e?new yi({header:t.header,staticAccountKeys:t.accountKeys.map((e=>new ei(e))),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Gt().decode(e.data)}))),addressTableLookups:t.addressTableLookups}):new mi(t)}const us=qr({foundation:zr(),foundationTerm:zr(),initial:zr(),taper:zr(),terminal:zr()}),ls=ss(_r(Rr(qr({epoch:zr(),effectiveSlot:zr(),amount:zr(),postBalance:zr(),commission:Nr(Rr(zr()))})))),ds=_r(qr({slot:zr(),prioritizationFee:zr()})),hs=qr({total:zr(),validator:zr(),foundation:zr(),epoch:zr()}),fs=qr({epoch:zr(),slotIndex:zr(),slotsInEpoch:zr(),absoluteSlot:zr(),blockHeight:Nr(zr()),transactionCount:Nr(zr())}),ps=qr({slotsPerEpoch:zr(),leaderScheduleSlotOffset:zr(),warmup:Tr(),firstNormalEpoch:zr(),firstNormalSlot:zr()}),gs=Ur(Mr(),_r(zr())),ms=Rr(Wr([qr({}),Mr()])),ys=qr({err:ms}),bs=jr("receivedSignature"),ws=qr({"solana-core":Mr(),"feature-set":Nr(zr())}),Ss=qr({program:Mr(),programId:Yi,parsed:Kr()}),ks=qr({programId:Yi,accounts:_r(Yi),data:Mr()}),vs=os(qr({err:Rr(Wr([qr({}),Mr()])),logs:Rr(_r(Mr())),accounts:Nr(Rr(_r(Rr(qr({executable:Tr(),owner:Mr(),lamports:zr(),data:_r(Mr()),rentEpoch:Nr(zr())}))))),unitsConsumed:Nr(zr()),returnData:Nr(Rr(qr({programId:Mr(),data:Lr([Mr(),jr("base64")])}))),innerInstructions:Nr(Rr(_r(qr({index:zr(),instructions:_r(Wr([Ss,ks]))}))))})),Is=os(qr({byIdentity:Ur(Mr(),_r(zr())),range:qr({firstSlot:zr(),lastSlot:zr()})}));const Bs=ss(us),Es=ss(hs),xs=ss(ds),As=ss(fs),Os=ss(ps),_s=ss(gs),Ts=ss(zr()),Ps=os(qr({total:zr(),circulating:zr(),nonCirculating:zr(),nonCirculatingAccounts:_r(Yi)})),js=qr({amount:Mr(),uiAmount:Rr(zr()),decimals:zr(),uiAmountString:Nr(Mr())}),Cs=os(_r(qr({address:Yi,amount:Mr(),uiAmount:Rr(zr()),decimals:zr(),uiAmountString:Nr(Mr())}))),Rs=os(_r(qr({pubkey:Yi,account:qr({executable:Tr(),owner:Yi,lamports:zr(),data:es,rentEpoch:zr()})}))),zs=qr({program:Mr(),parsed:Kr(),space:zr()}),Ns=os(_r(qr({pubkey:Yi,account:qr({executable:Tr(),owner:Yi,lamports:zr(),data:zs,rentEpoch:zr()})}))),Us=os(_r(qr({lamports:zr(),address:Yi}))),Ms=qr({executable:Tr(),owner:Yi,lamports:zr(),data:es,rentEpoch:zr()}),Ls=qr({pubkey:Yi,account:Ms}),qs=Dr(Wr([Pr(n.Buffer),zs]),Wr([Qi,zs]),(e=>Array.isArray(e)?Er(e,es):e)),Ws=qr({executable:Tr(),owner:Yi,lamports:zr(),data:qs,rentEpoch:zr()}),Ks=qr({pubkey:Yi,account:Ws}),Ds=qr({state:Wr([jr("active"),jr("inactive"),jr("activating"),jr("deactivating")]),active:zr(),inactive:zr()}),$s=ss(_r(qr({signature:Mr(),slot:zr(),err:ms,memo:Rr(Mr()),blockTime:Nr(Rr(zr()))}))),Vs=ss(_r(qr({signature:Mr(),slot:zr(),err:ms,memo:Rr(Mr()),blockTime:Nr(Rr(zr()))}))),Fs=qr({subscription:zr(),result:as(Ms)}),Hs=qr({pubkey:Yi,account:Ms}),Gs=qr({subscription:zr(),result:as(Hs)}),Js=qr({parent:zr(),slot:zr(),root:zr()}),Zs=qr({subscription:zr(),result:Js}),Xs=Wr([qr({type:Wr([jr("firstShredReceived"),jr("completed"),jr("optimisticConfirmation"),jr("root")]),slot:zr(),timestamp:zr()}),qr({type:jr("createdBank"),parent:zr(),slot:zr(),timestamp:zr()}),qr({type:jr("frozen"),slot:zr(),timestamp:zr(),stats:qr({numTransactionEntries:zr(),numSuccessfulTransactions:zr(),numFailedTransactions:zr(),maxTransactionsPerEntry:zr()})}),qr({type:jr("dead"),slot:zr(),timestamp:zr(),err:Mr()})]),Ys=qr({subscription:zr(),result:Xs}),Qs=qr({subscription:zr(),result:as(Wr([ys,bs]))}),eo=qr({subscription:zr(),result:zr()}),to=qr({pubkey:Mr(),gossip:Rr(Mr()),tpu:Rr(Mr()),rpc:Rr(Mr()),version:Rr(Mr())}),ro=qr({votePubkey:Mr(),nodePubkey:Mr(),activatedStake:zr(),epochVoteAccount:Tr(),epochCredits:_r(Lr([zr(),zr(),zr()])),commission:zr(),lastVote:zr(),rootSlot:Rr(zr())}),no=ss(qr({current:_r(ro),delinquent:_r(ro)})),io=Wr([jr("processed"),jr("confirmed"),jr("finalized")]),so=qr({slot:zr(),confirmations:Rr(zr()),err:ms,confirmationStatus:Nr(io)}),oo=os(_r(Rr(so))),ao=ss(zr()),co=qr({accountKey:Yi,writableIndexes:_r(zr()),readonlyIndexes:_r(zr())}),uo=qr({signatures:_r(Mr()),message:qr({accountKeys:_r(Mr()),header:qr({numRequiredSignatures:zr(),numReadonlySignedAccounts:zr(),numReadonlyUnsignedAccounts:zr()}),instructions:_r(qr({accounts:_r(zr()),data:Mr(),programIdIndex:zr()})),recentBlockhash:Mr(),addressTableLookups:Nr(_r(co))})}),lo=qr({pubkey:Yi,signer:Tr(),writable:Tr(),source:Nr(Wr([jr("transaction"),jr("lookupTable")]))}),ho=qr({accountKeys:_r(lo),signatures:_r(Mr())}),fo=qr({parsed:Kr(),program:Mr(),programId:Yi}),po=qr({accounts:_r(Yi),data:Mr(),programId:Yi}),go=Dr(Wr([po,fo]),Wr([qr({parsed:Kr(),program:Mr(),programId:Mr()}),qr({accounts:_r(Mr()),data:Mr(),programId:Mr()})]),(e=>Er(e,"accounts"in e?po:fo))),mo=qr({signatures:_r(Mr()),message:qr({accountKeys:_r(lo),instructions:_r(go),recentBlockhash:Mr(),addressTableLookups:Nr(Rr(_r(co)))})}),yo=qr({accountIndex:zr(),mint:Mr(),owner:Nr(Mr()),programId:Nr(Mr()),uiTokenAmount:js}),bo=qr({writable:_r(Yi),readonly:_r(Yi)}),wo=qr({err:ms,fee:zr(),innerInstructions:Nr(Rr(_r(qr({index:zr(),instructions:_r(qr({accounts:_r(zr()),data:Mr(),programIdIndex:zr()}))})))),preBalances:_r(zr()),postBalances:_r(zr()),logMessages:Nr(Rr(_r(Mr()))),preTokenBalances:Nr(Rr(_r(yo))),postTokenBalances:Nr(Rr(_r(yo))),loadedAddresses:Nr(bo),computeUnitsConsumed:Nr(zr())}),So=qr({err:ms,fee:zr(),innerInstructions:Nr(Rr(_r(qr({index:zr(),instructions:_r(go)})))),preBalances:_r(zr()),postBalances:_r(zr()),logMessages:Nr(Rr(_r(Mr()))),preTokenBalances:Nr(Rr(_r(yo))),postTokenBalances:Nr(Rr(_r(yo))),loadedAddresses:Nr(bo),computeUnitsConsumed:Nr(zr())}),ko=Wr([jr(0),jr("legacy")]),vo=qr({pubkey:Mr(),lamports:zr(),postBalance:Rr(zr()),rewardType:Rr(Mr()),commission:Nr(Rr(zr()))}),Io=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),transactions:_r(qr({transaction:uo,meta:Rr(wo),version:Nr(ko)})),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),Bo=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),Eo=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),transactions:_r(qr({transaction:ho,meta:Rr(wo),version:Nr(ko)})),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),xo=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),transactions:_r(qr({transaction:mo,meta:Rr(So),version:Nr(ko)})),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),Ao=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),transactions:_r(qr({transaction:ho,meta:Rr(So),version:Nr(ko)})),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),Oo=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),rewards:Nr(_r(vo)),blockTime:Rr(zr()),blockHeight:Rr(zr())}))),_o=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),transactions:_r(qr({transaction:uo,meta:Rr(wo)})),rewards:Nr(_r(vo)),blockTime:Rr(zr())}))),To=ss(Rr(qr({blockhash:Mr(),previousBlockhash:Mr(),parentSlot:zr(),signatures:_r(Mr()),blockTime:Rr(zr())}))),Po=ss(Rr(qr({slot:zr(),meta:Rr(wo),blockTime:Nr(Rr(zr())),transaction:uo,version:Nr(ko)}))),jo=ss(Rr(qr({slot:zr(),transaction:mo,meta:Rr(So),blockTime:Nr(Rr(zr())),version:Nr(ko)}))),Co=os(qr({blockhash:Mr(),lastValidBlockHeight:zr()})),Ro=os(Tr()),zo=ss(_r(qr({slot:zr(),numTransactions:zr(),numSlots:zr(),samplePeriodSecs:zr()}))),No=os(Rr(qr({feeCalculator:qr({lamportsPerSignature:zr()})}))),Uo=ss(Mr()),Mo=ss(Mr()),Lo=qr({err:ms,logs:_r(Mr()),signature:Mr()}),qo=qr({result:as(Lo),subscription:zr()}),Wo={"solana-client":"js/1.0.0-maintenance"};class Ko{constructor(e,t){let r,n,i,s,o,a;var c;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const e={};return async t=>{const{commitment:r,config:n}=ts(t),i=this._buildArgs([],r,void 0,n),s=$i(i);return e[s]=e[s]??(async()=>{try{const e=Er(await this._rpcRequest("getBlockHeight",i),ss(zr()));if("error"in e)throw new Ai(e.error,"failed to get block height information");return e.result}finally{delete e[s]}})(),await e[s]}})(),t&&"string"==typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,n=t.httpHeaders,i=t.fetch,s=t.fetchMiddleware,o=t.disableRetryOnRateLimit,a=t.httpAgent),this._rpcEndpoint=function(e){if(!1===/^https?:/.test(e))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return e}(e),this._rpcWsEndpoint=r||function(e){const t=e.match(Xi);if(null==t)throw TypeError(`Failed to validate endpoint URL \`${e}\``);const[r,n,i,s]=t,o=e.startsWith("https:")?"wss:":"ws:",a=null==i?null:parseInt(i.slice(1),10);return`${o}//${n}${null==a?"":`:${a+1}`}${s}`}(e),this._rpcClient=function(e,t,r,n,i,s){const o=r||Hi;let a;return null!=s&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),n&&(a=async(e,t)=>{const r=await new Promise(((r,i)=>{try{n(e,t,((e,t)=>r([e,t])))}catch(e){i(e)}}));return await o(...r)}),new(Vr())((async(r,n)=>{const s={method:"POST",body:r,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},t||{},Wo)};try{let t,r=5,c=500;for(;t=a?await a(e,s):await o(e,s),429===t.status&&!0!==i&&(r-=1,0!==r);)console.error(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${c}ms delay...`),await _i(c),c*=2;const u=await t.text();t.ok?n(null,u):n(new Error(`${t.status} ${t.statusText}: ${u}`))}catch(e){e instanceof Error&&n(e)}}),{})}(e,n,i,s,o,a),this._rpcRequest=(c=this._rpcClient,(e,t)=>new Promise(((r,n)=>{c.request(e,t,((e,t)=>{e?n(e):r(t)}))}))),this._rpcBatchRequest=function(e){return t=>new Promise(((r,n)=>{0===t.length&&r([]);const i=t.map((t=>e.request(t.methodName,t.args)));e.request(i,((e,t)=>{e?n(e):r(t)}))}))}(this._rpcClient),this._rpcWebSocket=new Gi(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgs([e.toBase58()],r,void 0,n),s=Er(await this._rpcRequest("getBalance",i),os(zr()));if("error"in s)throw new Ai(s.error,`failed to get balance for ${e.toBase58()}`);return s.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then((e=>e.value)).catch((t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)}))}async getBlockTime(e){const t=Er(await this._rpcRequest("getBlockTime",[e]),ss(Rr(zr())));if("error"in t)throw new Ai(t.error,`failed to get block time for slot ${e}`);return t.result}async getMinimumLedgerSlot(){const e=Er(await this._rpcRequest("minimumLedgerSlot",[]),ss(zr()));if("error"in e)throw new Ai(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const e=Er(await this._rpcRequest("getFirstAvailableBlock",[]),Ts);if("error"in e)throw new Ai(e.error,"failed to get first available block");return e.result}async getSupply(e){let t={};t="string"==typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const r=Er(await this._rpcRequest("getSupply",[t]),Ps);if("error"in r)throw new Ai(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=Er(await this._rpcRequest("getTokenSupply",r),os(js));if("error"in n)throw new Ai(n.error,"failed to get token supply");return n.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=Er(await this._rpcRequest("getTokenAccountBalance",r),os(js));if("error"in n)throw new Ai(n.error,"failed to get token account balance");return n.result}async getTokenAccountsByOwner(e,t,r){const{commitment:n,config:i}=ts(r);let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"base64",i),a=Er(await this._rpcRequest("getTokenAccountsByOwner",o),Rs);if("error"in a)throw new Ai(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const i=this._buildArgs(n,r,"jsonParsed"),s=Er(await this._rpcRequest("getTokenAccountsByOwner",i),Ns);if("error"in s)throw new Ai(s.error,`failed to get token accounts owned by account ${e.toBase58()}`);return s.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=Er(await this._rpcRequest("getLargestAccounts",r),Us);if("error"in n)throw new Ai(n.error,"failed to get largest accounts");return n.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=Er(await this._rpcRequest("getTokenLargestAccounts",r),Cs);if("error"in n)throw new Ai(n.error,"failed to get token largest accounts");return n.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgs([e.toBase58()],r,"base64",n),s=Er(await this._rpcRequest("getAccountInfo",i),os(Rr(Ms)));if("error"in s)throw new Ai(s.error,`failed to get info about account ${e.toBase58()}`);return s.result}async getParsedAccountInfo(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=Er(await this._rpcRequest("getAccountInfo",i),os(Rr(Ws)));if("error"in s)throw new Ai(s.error,`failed to get info about account ${e.toBase58()}`);return s.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(t){throw new Error("failed to get info about account "+e.toBase58()+": "+t)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:n}=ts(t),i=e.map((e=>e.toBase58())),s=this._buildArgs([i],r,"jsonParsed",n),o=Er(await this._rpcRequest("getMultipleAccounts",s),os(_r(Rr(Ws))));if("error"in o)throw new Ai(o.error,`failed to get info for accounts ${i}`);return o.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:n}=ts(t),i=e.map((e=>e.toBase58())),s=this._buildArgs([i],r,"base64",n),o=Er(await this._rpcRequest("getMultipleAccounts",s),os(_r(Rr(Ms))));if("error"in o)throw new Ai(o.error,`failed to get info for accounts ${i}`);return o.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:n,config:i}=ts(t),s=this._buildArgs([e.toBase58()],n,void 0,{...i,epoch:null!=r?r:i?.epoch}),o=Er(await this._rpcRequest("getStakeActivation",s),ss(Ds));if("error"in o)throw new Ai(o.error,`failed to get Stake Activation ${e.toBase58()}`);return o.result}async getProgramAccounts(e,t){const{commitment:r,config:n}=ts(t),{encoding:i,...s}=n||{},o=this._buildArgs([e.toBase58()],r,i||"base64",{...s,...s.filters?{filters:rs(s.filters)}:null}),a=await this._rpcRequest("getProgramAccounts",o),c=_r(Ls),u=!0===s.withContext?Er(a,os(c)):Er(a,ss(c));if("error"in u)throw new Ai(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgs([e.toBase58()],r,"jsonParsed",n),s=Er(await this._rpcRequest("getProgramAccounts",i),ss(_r(Ks)));if("error"in s)throw new Ai(s.error,`failed to get accounts owned by program ${e.toBase58()}`);return s.result}async confirmTransaction(e,t){let r,n;if("string"==typeof e)r=e;else{const t=e;if(t.abortSignal?.aborted)return Promise.reject(t.abortSignal.reason);r=t.signature}try{n=Gt().decode(r)}catch(e){throw new Error("signature must be base58 encoded: "+r)}return di(64===n.length,"signature has invalid length"),"string"==typeof e?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise(((t,r)=>{null!=e&&(e.aborted?r(e.reason):e.addEventListener("abort",(()=>{r(e.reason)})))}))}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,n,i=!1;return{abortConfirmation:()=>{n&&(n(),n=void 0),null!=r&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:new Promise(((s,o)=>{try{r=this.onSignature(t,((e,t)=>{r=void 0;const n={context:t,value:e};s({__type:bi.PROCESSED,response:n})}),e);const a=new Promise((e=>{null==r?e():n=this._onSubscriptionStateChange(r,(t=>{"subscribed"===t&&e()}))}));(async()=>{if(await a,i)return;const r=await this.getSignatureStatus(t);if(i)return;if(null==r)return;const{context:n,value:c}=r;if(null!=c)if(c?.err)o(c.err);else{switch(e){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return}i=!0,s({__type:bi.PROCESSED,response:{context:n,value:c}})}})()}catch(e){o(e)}}))}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:n}}){let i=!1;const s=new Promise((t=>{const n=async()=>{try{return await this.getBlockHeight(e)}catch(e){return-1}};(async()=>{let e=await n();if(!i){for(;e<=r;){if(await _i(1e3),i)return;if(e=await n(),i)return}t({__type:bi.BLOCKHEIGHT_EXCEEDED})}})()})),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:n}),c=this.getCancellationPromise(t);let u;try{const e=await Promise.race([c,a,s]);if(e.__type!==bi.PROCESSED)throw new ri(n);u=e.response}finally{i=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:n,nonceValue:i,signature:s}}){let o=!1;const a=new Promise((t=>{let s=i,a=null;const c=async()=>{try{const{context:t,value:i}=await this.getNonceAndContext(n,{commitment:e,minContextSlot:r});return a=t.slot,i?.nonce}catch(e){return s}};(async()=>{if(s=await c(),!o)for(;;){if(i!==s)return void t({__type:bi.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await _i(2e3),o)return;if(s=await c(),o)return}})()})),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let d;try{const t=await Promise.race([l,u,a]);if(t.__type===bi.PROCESSED)d=t.response;else{let n;for(;;){const e=await this.getSignatureStatus(s);if(null==e)break;if(!(e.context.slot<(t.slotInWhichNonceDidAdvance??r))){n=e;break}await _i(400)}if(!n?.value)throw new ii(s);{const t=e||"finalized",{confirmationStatus:r}=n.value;switch(t){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new ii(s);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new ii(s);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new ii(s)}d={context:n.context,value:{err:n.value.err}}}}}finally{o=!0,c()}return d}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const n=new Promise((t=>{let n=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":n=this._confirmTransactionInitialTimeout||3e4}r=setTimeout((()=>t({__type:bi.TIMED_OUT,timeoutMs:n})),n)})),{abortConfirmation:i,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let o;try{const e=await Promise.race([s,n]);if(e.__type!==bi.PROCESSED)throw new ni(t,e.timeoutMs/1e3);o=e.response}finally{clearTimeout(r),i()}return o}async getClusterNodes(){const e=Er(await this._rpcRequest("getClusterNodes",[]),ss(_r(to)));if("error"in e)throw new Ai(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=Er(await this._rpcRequest("getVoteAccounts",t),no);if("error"in r)throw new Ai(r.error,"failed to get vote accounts");return r.result}async getSlot(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,void 0,r),i=Er(await this._rpcRequest("getSlot",n),ss(zr()));if("error"in i)throw new Ai(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,void 0,r),i=Er(await this._rpcRequest("getSlotLeader",n),ss(Mr()));if("error"in i)throw new Ai(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],n=Er(await this._rpcRequest("getSlotLeaders",r),ss(_r(Yi)));if("error"in n)throw new Ai(n.error,"failed to get slot leaders");return n.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);di(1===n.length);return{context:r,value:n[0]}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=Er(await this._rpcRequest("getSignatureStatuses",r),oo);if("error"in n)throw new Ai(n.error,"failed to get signature status");return n.result}async getTransactionCount(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,void 0,r),i=Er(await this._rpcRequest("getTransactionCount",n),ss(zr()));if("error"in i)throw new Ai(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=Er(await this._rpcRequest("getInflationGovernor",t),Bs);if("error"in r)throw new Ai(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,r){const{commitment:n,config:i}=ts(r),s=this._buildArgs([e.map((e=>e.toBase58()))],n,void 0,{...i,epoch:null!=t?t:i?.epoch}),o=Er(await this._rpcRequest("getInflationReward",s),ls);if("error"in o)throw new Ai(o.error,"failed to get inflation reward");return o.result}async getInflationRate(){const e=Er(await this._rpcRequest("getInflationRate",[]),Es);if("error"in e)throw new Ai(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,void 0,r),i=Er(await this._rpcRequest("getEpochInfo",n),As);if("error"in i)throw new Ai(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=Er(await this._rpcRequest("getEpochSchedule",[]),Os);if("error"in e)throw new Ai(e.error,"failed to get epoch schedule");const t=e.result;return new Fi(t.slotsPerEpoch,t.leaderScheduleSlotOffset,t.warmup,t.firstNormalEpoch,t.firstNormalSlot)}async getLeaderSchedule(){const e=Er(await this._rpcRequest("getLeaderSchedule",[]),_s);if("error"in e)throw new Ai(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=Er(await this._rpcRequest("getMinimumBalanceForRentExemption",r),ao);return"error"in n?(console.warn("Unable to fetch minimum balance for rent exemption"),0):n.result}async getRecentBlockhashAndContext(e){const{context:t,value:{blockhash:r}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:r,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON:()=>({})}}}}async getRecentPerformanceSamples(e){const t=Er(await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),zo);if("error"in t)throw new Ai(t.error,"failed to get recent performance samples");return t.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=Er(await this._rpcRequest("getFeeCalculatorForBlockhash",r),No);if("error"in n)throw new Ai(n.error,"failed to get fee calculator");const{context:i,value:s}=n.result;return{context:i,value:null!==s?s.feeCalculator:null}}async getFeeForMessage(e,t){const r=Gn(e.serialize()).toString("base64"),n=this._buildArgs([r],t),i=Er(await this._rpcRequest("getFeeForMessage",n),os(Rr(zr())));if("error"in i)throw new Ai(i.error,"failed to get fee for message");if(null===i.result)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map((e=>e.toBase58())),r=t?.length?[t]:[],n=Er(await this._rpcRequest("getRecentPrioritizationFees",r),xs);if("error"in n)throw new Ai(n.error,"failed to get recent prioritization fees");return n.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,void 0,r),i=Er(await this._rpcRequest("getLatestBlockhash",n),Co);if("error"in i)throw new Ai(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgs([e],r,void 0,n),s=Er(await this._rpcRequest("isBlockhashValid",i),Ro);if("error"in s)throw new Ai(s.error,"failed to determine if the blockhash `"+e+"`is valid");return s.result}async getVersion(){const e=Er(await this._rpcRequest("getVersion",[]),ss(ws));if("error"in e)throw new Ai(e.error,"failed to get version");return e.result}async getGenesisHash(){const e=Er(await this._rpcRequest("getGenesisHash",[]),ss(Mr()));if("error"in e)throw new Ai(e.error,"failed to get genesis hash");return e.result}async getBlock(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=await this._rpcRequest("getBlock",i);try{switch(n?.transactionDetails){case"accounts":{const e=Er(s,Eo);if("error"in e)throw e.error;return e.result}case"none":{const e=Er(s,Bo);if("error"in e)throw e.error;return e.result}default:{const e=Er(s,Io);if("error"in e)throw e.error;const{result:t}=e;return t?{...t,transactions:t.transactions.map((({transaction:e,meta:t,version:r})=>({meta:t,transaction:{...e,message:cs(r,e.message)},version:r})))}:null}}}catch(e){throw new Ai(e,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=await this._rpcRequest("getBlock",i);try{switch(n?.transactionDetails){case"accounts":{const e=Er(s,Ao);if("error"in e)throw e.error;return e.result}case"none":{const e=Er(s,Oo);if("error"in e)throw e.error;return e.result}default:{const e=Er(s,xo);if("error"in e)throw e.error;return e.result}}}catch(e){throw new Ai(e,"failed to get block")}}async getBlockProduction(e){let t,r;if("string"==typeof e)r=e;else if(e){const{commitment:n,...i}=e;r=n,t=i}const n=this._buildArgs([],r,"base64",t),i=Er(await this._rpcRequest("getBlockProduction",n),Is);if("error"in i)throw new Ai(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgsAtLeastConfirmed([e],r,void 0,n),s=Er(await this._rpcRequest("getTransaction",i),Po);if("error"in s)throw new Ai(s.error,"failed to get transaction");const o=s.result;return o?{...o,transaction:{...o.transaction,message:cs(o.version,o.transaction.message)}}:o}async getParsedTransaction(e,t){const{commitment:r,config:n}=ts(t),i=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n),s=Er(await this._rpcRequest("getTransaction",i),jo);if("error"in s)throw new Ai(s.error,"failed to get transaction");return s.result}async getParsedTransactions(e,t){const{commitment:r,config:n}=ts(t),i=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",n)})));return(await this._rpcBatchRequest(i)).map((e=>{const t=Er(e,jo);if("error"in t)throw new Ai(t.error,"failed to get transactions");return t.result}))}async getTransactions(e,t){const{commitment:r,config:n}=ts(t),i=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],r,void 0,n)})));return(await this._rpcBatchRequest(i)).map((e=>{const t=Er(e,Po);if("error"in t)throw new Ai(t.error,"failed to get transactions");const r=t.result;return r?{...r,transaction:{...r.transaction,message:cs(r.version,r.transaction.message)}}:r}))}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=Er(await this._rpcRequest("getBlock",r),_o);if("error"in n)throw new Ai(n.error,"failed to get confirmed block");const i=n.result;if(!i)throw new Error("Confirmed block "+e+" not found");const s={...i,transactions:i.transactions.map((({transaction:e,meta:t})=>{const r=new mi(e.message);return{meta:t,transaction:{...e,message:r}}}))};return{...s,transactions:s.transactions.map((({transaction:e,meta:t})=>({meta:t,transaction:ki.populate(e.message,e.signatures)})))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],r),i=Er(await this._rpcRequest("getBlocks",n),ss(_r(zr())));if("error"in i)throw new Ai(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=Er(await this._rpcRequest("getBlock",r),To);if("error"in n)throw new Ai(n.error,"failed to get block");const i=n.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=Er(await this._rpcRequest("getBlock",r),To);if("error"in n)throw new Ai(n.error,"failed to get confirmed block");const i=n.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=Er(await this._rpcRequest("getTransaction",r),Po);if("error"in n)throw new Ai(n.error,"failed to get transaction");const i=n.result;if(!i)return i;const s=new mi(i.transaction.message),o=i.transaction.signatures;return{...i,transaction:ki.populate(s,o)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=Er(await this._rpcRequest("getTransaction",r),jo);if("error"in n)throw new Ai(n.error,"failed to get confirmed transaction");return n.result}async getParsedConfirmedTransactions(e,t){const r=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],t,"jsonParsed")})));return(await this._rpcBatchRequest(r)).map((e=>{const t=Er(e,jo);if("error"in t)throw new Ai(t.error,"failed to get confirmed transactions");return t.result}))}async getConfirmedSignaturesForAddress(e,t,r){let n={},i=await this.getFirstAvailableBlock();for(;!("until"in n)&&!(--t<=0||t<i);)try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(n.until=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}let s=await this.getSlot("finalized");for(;!("before"in n||++r>s);)try{const e=await this.getConfirmedBlockSignatures(r);e.signatures.length>0&&(n.before=e.signatures[e.signatures.length-1].toString())}catch(e){if(e instanceof Error&&e.message.includes("skipped"))continue;throw e}return(await this.getConfirmedSignaturesForAddress2(e,n)).map((e=>e.signature))}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=Er(await this._rpcRequest("getConfirmedSignaturesForAddress2",n),$s);if("error"in i)throw new Ai(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),i=Er(await this._rpcRequest("getSignaturesForAddress",n),Vs);if("error"in i)throw new Ai(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=new Ji({key:e,state:Ji.deserialize(n.data)})),{context:r,value:i}}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let i=null;return null!==n&&(i=Ri.fromAccountData(n.data)),{context:r,value:i}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then((e=>e.value)).catch((t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)}))}async requestAirdrop(e,t){const r=Er(await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),Uo);if("error"in r)throw new Ai(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await _i(100);const e=Date.now()-this._blockhashInfo.lastFetch>=3e4;if(null!==this._blockhashInfo.latestBlockhash&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let e=0;e<50;e++){const e=await this.getLatestBlockhash("finalized");if(r!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await _i(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=ts(e),n=this._buildArgs([],t,"base64",r),i=Er(await this._rpcRequest("getStakeMinimumDelegation",n),os(zr()));if("error"in i)throw new Ai(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const i=e.serialize(),s=n.Buffer.from(i).toString("base64");if(Array.isArray(t)||void 0!==r)throw new Error("Invalid arguments");const o=t||{};o.encoding="base64","commitment"in o||(o.commitment=this.commitment),t&&"object"==typeof t&&"innerInstructions"in t&&(o.innerInstructions=t.innerInstructions);const a=[s,o],c=Er(await this._rpcRequest("simulateTransaction",a),vs);if("error"in c)throw new Error("failed to simulate transaction: "+c.error.message);return c.result}let i;if(e instanceof ki){let t=e;i=new ki,i.feePayer=t.feePayer,i.instructions=e.instructions,i.nonceInfo=t.nonceInfo,i.signatures=t.signatures}else i=ki.populate(e),i._message=i._json=void 0;if(void 0!==t&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(i.nonceInfo&&s)i.sign(...s);else{let e=this._disableBlockhashCaching;for(;;){const t=await this._blockhashWithExpiryBlockHeight(e);if(i.lastValidBlockHeight=t.lastValidBlockHeight,i.recentBlockhash=t.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const r=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(r)&&!this._blockhashInfo.transactionSignatures.includes(r)){this._blockhashInfo.simulatedSignatures.push(r);break}e=!0}}const o=i._compile(),a=o.serialize(),c=i._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(r){const e=(Array.isArray(r)?r:o.nonProgramIds()).map((e=>e.toBase58()));u.accounts={encoding:"base64",addresses:e}}s&&(u.sigVerify=!0),t&&"object"==typeof t&&"innerInstructions"in t&&(u.innerInstructions=t.innerInstructions);const l=[c,u],d=Er(await this._rpcRequest("simulateTransaction",l),vs);if("error"in d){let e;if("data"in d.error&&(e=d.error.data.logs,e&&Array.isArray(e))){const t="\n    ",r=t+e.join(t);console.error(d.error.message,r)}throw new xi({action:"simulate",signature:"",transactionMessage:d.error.message,logs:e})}return d.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const r=e.serialize();return await this.sendRawTransaction(r,t)}if(void 0===t||!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(e.nonceInfo)e.sign(...n);else{let t=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(t);if(e.lastValidBlockHeight=r.lastValidBlockHeight,e.recentBlockhash=r.blockhash,e.sign(...n),!e.signature)throw new Error("!signature");const i=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(i)){this._blockhashInfo.transactionSignatures.push(i);break}t=!0}}const i=e.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(e,t){const r=Gn(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,i=!0===n?"processed":t&&t.preflightCommitment||this.commitment;t&&null!=t.maxRetries&&(r.maxRetries=t.maxRetries),t&&null!=t.minContextSlot&&(r.minContextSlot=t.minContextSlot),n&&(r.skipPreflight=n),i&&(r.preflightCommitment=i);const s=[e,r],o=Er(await this._rpcRequest("sendTransaction",s),Mo);if("error"in o){let e;throw"data"in o.error&&(e=o.error.data.logs),new xi({action:n?"send":"simulate",signature:"",transactionMessage:o.error.message,logs:e})}return o.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()}),5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((([e,t])=>{this._setSubscription(e,{...t,state:"pending"})}))):this._updateSubscriptions()}_setSubscription(e,t){const r=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach((e=>{try{e(t.state)}catch{}}))}}_onSubscriptionStateChange(e,t){const r=this._subscriptionHashByClientSubscriptionId[e];if(null==r)return()=>{};const n=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return n.add(t),()=>{n.delete(t),0===n.size&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){e instanceof Error&&console.log(`Error when closing socket connection: ${e.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:i}=r;try{this._setSubscription(e,{...r,state:"subscribing"});const t=await this._rpcWebSocket.call(i,n);this._setSubscription(e,{...r,serverSubscriptionId:t,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[t]=r.callbacks,await this._updateSubscriptions()}catch(s){if(console.error(`Received ${s instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:n,error:s}),!t())return;this._setSubscription(e,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(e,{...r,state:"unsubscribing"}),this._setSubscription(e,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(n){if(n instanceof Error&&console.error(`${i} error:`,n.message),!t())return;return this._setSubscription(e,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(e,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})()}})))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==r&&r.forEach((e=>{try{e(...t)}catch(e){console.error(e)}}))}_wsOnAccountNotification(e){const{result:t,subscription:r}=Er(e,Fs);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=$i([e.method,t]),i=this._subscriptionsByHash[n];return void 0===i?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:i.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const t=this._subscriptionsByHash[n];di(void 0!==t,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const{commitment:n,config:i}=ts(r),s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",i);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=Er(e,Gs);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const{commitment:i,config:s}=ts(r),o=this._buildArgs([e.toBase58()],i||this._commitment||"finalized","base64",s||(n?{filters:rs(n)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs(["object"==typeof e?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=Er(e,qo);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=Er(e,Zs);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=Er(e,Ys);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){const i=t||this._commitment;if(i||r||n){let t={};r&&(t.encoding=r),i&&(t.commitment=i),n&&(t=Object.assign(t,n)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const i=t||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=Er(e,Qs);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(e,r)=>{if("status"===e.type){t(e.result,r);try{this.removeSignatureListener(i)}catch(e){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return i}onSignatureWithOptions(e,t,r){const{commitment:n,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},s=this._buildArgs([e],n,void 0,i),o=this._makeSubscription({callback:(e,r)=>{t(e,r);try{this.removeSignatureListener(o)}catch(e){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=Er(e,eo);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Do{constructor(e){this._keypair=void 0,this._keypair=e??Dn()}static generate(){return new Do(Dn())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=$n(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new Do({publicKey:r,secretKey:e})}static fromSeed(e){const t=$n(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Do({publicKey:t,secretKey:r})}get publicKey(){return new ei(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const $o=Object.freeze({CreateLookupTable:{index:0,layout:gr.n_([gr.Jq("instruction"),zi("recentSlot"),gr.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:gr.n_([gr.Jq("instruction")])},ExtendLookupTable:{index:2,layout:gr.n_([gr.Jq("instruction"),zi(),gr.A9(oi(),gr.cv(gr.Jq(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:gr.n_([gr.Jq("instruction")])},CloseLookupTable:{index:4,layout:gr.n_([gr.Jq("instruction")])}});class Vo{constructor(){}static createLookupTable(e){const[t,r]=ei.findProgramAddressSync([e.authority.toBuffer(),(0,mr.k$)(BigInt(e.recentSlot),8)],this.programId),n=Ti($o.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Mi.programId,isSigner:!1,isWritable:!1}];return[new Si({programId:this.programId,keys:i,data:n}),t]}static freezeLookupTable(e){const t=Ti($o.FreezeLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Si({programId:this.programId,keys:r,data:t})}static extendLookupTable(e){const t=Ti($o.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Mi.programId,isSigner:!1,isWritable:!1}),new Si({programId:this.programId,keys:r,data:t})}static deactivateLookupTable(e){const t=Ti($o.DeactivateLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Si({programId:this.programId,keys:r,data:t})}static closeLookupTable(e){const t=Ti($o.CloseLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new Si({programId:this.programId,keys:r,data:t})}}Vo.programId=new ei("AddressLookupTab1e1111111111111111111111111");const Fo=Object.freeze({RequestUnits:{index:0,layout:gr.n_([gr.u8("instruction"),gr.Jq("units"),gr.Jq("additionalFee")])},RequestHeapFrame:{index:1,layout:gr.n_([gr.u8("instruction"),gr.Jq("bytes")])},SetComputeUnitLimit:{index:2,layout:gr.n_([gr.u8("instruction"),gr.Jq("units")])},SetComputeUnitPrice:{index:3,layout:gr.n_([gr.u8("instruction"),zi("microLamports")])}});class Ho{constructor(){}static requestUnits(e){const t=Ti(Fo.RequestUnits,e);return new Si({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){const t=Ti(Fo.RequestHeapFrame,e);return new Si({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){const t=Ti(Fo.SetComputeUnitLimit,e);return new Si({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){const t=Ti(Fo.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new Si({keys:[],programId:this.programId,data:t})}}Ho.programId=new ei("ComputeBudget111111111111111111111111111111");const Go=gr.n_([gr.u8("numSignatures"),gr.u8("padding"),gr.KB("signatureOffset"),gr.KB("signatureInstructionIndex"),gr.KB("publicKeyOffset"),gr.KB("publicKeyInstructionIndex"),gr.KB("messageDataOffset"),gr.KB("messageDataSize"),gr.KB("messageInstructionIndex")]);class Jo{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:i,instructionIndex:s}=e;di(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),di(64===i.length,`Signature must be 64 bytes but received ${i.length} bytes`);const o=Go.span,a=o+t.length,c=a+i.length,u=n.Buffer.alloc(c+r.length),l=null==s?65535:s;return Go.encode({numSignatures:1,padding:0,signatureOffset:a,signatureInstructionIndex:l,publicKeyOffset:o,publicKeyInstructionIndex:l,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:l},u),u.fill(t,o),u.fill(i,a),u.fill(r,c),new Si({keys:[],programId:Jo.programId,data:u})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;di(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=Do.fromSecretKey(t),i=e.publicKey.toBytes(),s=Fn(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:s,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Jo.programId=new ei("Ed25519SigVerify111111111111111111111111111");Kn.utils.isValidPrivateKey;const Zo=Kn.getPublicKey,Xo=gr.n_([gr.u8("numSignatures"),gr.KB("signatureOffset"),gr.u8("signatureInstructionIndex"),gr.KB("ethAddressOffset"),gr.u8("ethAddressInstructionIndex"),gr.KB("messageDataOffset"),gr.KB("messageDataSize"),gr.u8("messageInstructionIndex"),gr.Ik(20,"ethAddress"),gr.Ik(64,"signature"),gr.u8("recoveryId")]);class Yo{constructor(){}static publicKeyToEthAddress(e){di(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return n.Buffer.from(yn(Gn(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:i,instructionIndex:s}=e;return Yo.createInstructionWithEthAddress({ethAddress:Yo.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:i,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"==typeof t?t.startsWith("0x")?n.Buffer.from(t.substr(2),"hex"):n.Buffer.from(t,"hex"):t,di(20===a.length,`Address must be 20 bytes but received ${a.length} bytes`);const c=12+a.length,u=c+i.length+1,l=n.Buffer.alloc(Xo.span+r.length);return Xo.encode({numSignatures:1,signatureOffset:c,signatureInstructionIndex:o,ethAddressOffset:12,ethAddressInstructionIndex:o,messageDataOffset:u,messageDataSize:r.length,messageInstructionIndex:o,signature:Gn(i),ethAddress:Gn(a),recoveryId:s},l),l.fill(Gn(r),Xo.span),new Si({keys:[],programId:Yo.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:i}=e;di(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=Gn(t),s=Zo(e,!1).slice(1),o=n.Buffer.from(yn(Gn(r))),[a,c]=((e,t)=>{const r=Kn.sign(e,t);return[r.toCompactRawBytes(),r.recovery]})(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:c,instructionIndex:i})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var Qo;Yo.programId=new ei("KeccakSecp256k11111111111111111111111111111");const ea=new ei("StakeConfig11111111111111111111111111111111");class ta{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Qo=ta,ta.default=new Qo(0,0,ei.default);const ra=Object.freeze({Initialize:{index:0,layout:gr.n_([gr.Jq("instruction"),((e="authorized")=>gr.n_([oi("staker"),oi("withdrawer")],e))(),((e="lockup")=>gr.n_([gr.gM("unixTimestamp"),gr.gM("epoch"),oi("custodian")],e))()])},Authorize:{index:1,layout:gr.n_([gr.Jq("instruction"),oi("newAuthorized"),gr.Jq("stakeAuthorizationType")])},Delegate:{index:2,layout:gr.n_([gr.Jq("instruction")])},Split:{index:3,layout:gr.n_([gr.Jq("instruction"),gr.gM("lamports")])},Withdraw:{index:4,layout:gr.n_([gr.Jq("instruction"),gr.gM("lamports")])},Deactivate:{index:5,layout:gr.n_([gr.Jq("instruction")])},Merge:{index:7,layout:gr.n_([gr.Jq("instruction")])},AuthorizeWithSeed:{index:8,layout:gr.n_([gr.Jq("instruction"),oi("newAuthorized"),gr.Jq("stakeAuthorizationType"),ai("authoritySeed"),oi("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class na{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,i=n||ta.default,s=Ti(ra.Initialize,{authorized:{staker:Gn(r.staker.toBuffer()),withdrawer:Gn(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:Gn(i.custodian.toBuffer())}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Bi,isSigner:!1,isWritable:!1}],programId:this.programId,data:s};return new Si(o)}static createAccountWithSeed(e){const t=new ki;t.add(Mi.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static createAccount(e){const t=new ki;t.add(Mi.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,i=Ti(ra.Delegate);return(new ki).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:Ei,isSigner:!1,isWritable:!1},{pubkey:ea,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:i,custodianPubkey:s}=e,o=Ti(ra.Authorize,{newAuthorized:Gn(n.toBuffer()),stakeAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&a.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ki).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,c=Ti(ra.AuthorizeWithSeed,{newAuthorized:Gn(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:Gn(i.toBuffer())}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:vi,isSigner:!1,isWritable:!1}];return a&&u.push({pubkey:a,isSigner:!0,isWritable:!1}),(new ki).add({keys:u,programId:this.programId,data:c})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:i}=e,s=Ti(ra.Split,{lamports:i});return new Si({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static split(e,t){const r=new ki;return r.add(Mi.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,c=new ki;return c.add(Mi.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&c.add(Mi.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),c.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,i=Ti(ra.Merge);return(new ki).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:Ei,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:i,custodianPubkey:s}=e,o=Ti(ra.Withdraw,{lamports:i}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:Ei,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&a.push({pubkey:s,isSigner:!0,isWritable:!1}),(new ki).add({keys:a,programId:this.programId,data:o})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=Ti(ra.Deactivate);return(new ki).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}na.programId=new ei("Stake11111111111111111111111111111111111111"),na.space=200;const ia=Object.freeze({InitializeAccount:{index:0,layout:gr.n_([gr.Jq("instruction"),((e="voteInit")=>gr.n_([oi("nodePubkey"),oi("authorizedVoter"),oi("authorizedWithdrawer"),gr.u8("commission")],e))()])},Authorize:{index:1,layout:gr.n_([gr.Jq("instruction"),oi("newAuthorized"),gr.Jq("voteAuthorizationType")])},Withdraw:{index:3,layout:gr.n_([gr.Jq("instruction"),gr.gM("lamports")])},UpdateValidatorIdentity:{index:4,layout:gr.n_([gr.Jq("instruction")])},AuthorizeWithSeed:{index:10,layout:gr.n_([gr.Jq("instruction"),((e="voteAuthorizeWithSeedArgs")=>gr.n_([gr.Jq("voteAuthorizationType"),oi("currentAuthorityDerivedKeyOwnerPubkey"),ai("currentAuthorityDerivedKeySeed"),oi("newAuthorized")],e))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class sa{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,i=Ti(ia.InitializeAccount,{voteInit:{nodePubkey:Gn(n.nodePubkey.toBuffer()),authorizedVoter:Gn(n.authorizedVoter.toBuffer()),authorizedWithdrawer:Gn(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),s={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Bi,isSigner:!1,isWritable:!1},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new Si(s)}static createAccount(e){const t=new ki;return t.add(Mi.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:i}=e,s=Ti(ia.Authorize,{newAuthorized:Gn(n.toBuffer()),voteAuthorizationType:i.index}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ki).add({keys:o,programId:this.programId,data:s})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=Ti(ia.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Gn(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:Gn(i.toBuffer()),voteAuthorizationType:s.index}}),c=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:vi,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new ki).add({keys:c,programId:this.programId,data:a})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:i}=e,s=Ti(ia.Withdraw,{lamports:n}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ki).add({keys:o,programId:this.programId,data:s})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return sa.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,i=Ti(ia.UpdateValidatorIdentity),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ki).add({keys:s,programId:this.programId,data:i})}}sa.programId=new ei("Vote111111111111111111111111111111111111111"),sa.space=3762;new ei("Va1idator1nfo111111111111111111111111111111"),qr({name:Mr(),website:Nr(Mr()),details:Nr(Mr()),iconUrl:Nr(Mr()),keybaseUsername:Nr(Mr())});new ei("Vote111111111111111111111111111111111111111"),gr.n_([oi("nodePubkey"),oi("authorizedWithdrawer"),gr.u8("commission"),gr._O(),gr.A9(gr.n_([gr._O("slot"),gr.Jq("confirmationCount")]),gr.cv(gr.Jq(),-8),"votes"),gr.u8("rootSlotValid"),gr._O("rootSlot"),gr._O(),gr.A9(gr.n_([gr._O("epoch"),oi("authorizedVoter")]),gr.cv(gr.Jq(),-8),"authorizedVoters"),gr.n_([gr.A9(gr.n_([oi("authorizedPubkey"),gr._O("epochOfLastAuthorizedSwitch"),gr._O("targetEpoch")]),32,"buf"),gr._O("idx"),gr.u8("isEmpty")],"priorVoters"),gr._O(),gr.A9(gr.n_([gr._O("epoch"),gr._O("credits"),gr._O("prevCredits")]),gr.cv(gr.Jq(),-8),"epochCredits"),gr.n_([gr._O("slot"),gr._O("timestamp")],"lastTimestamp")])},98639:(e,t,r)=>{"use strict";const n=r(81298).v4,i=r(81435),s=function(e,t){if(!(this instanceof s))return new s(e,t);t||(t={}),this.options={reviver:void 0!==t.reviver?t.reviver:null,replacer:void 0!==t.replacer?t.replacer:null,generator:void 0!==t.generator?t.generator:function(){return n()},version:void 0!==t.version?t.version:2,notificationIdNull:"boolean"==typeof t.notificationIdNull&&t.notificationIdNull},this.callServer=e};e.exports=s,s.prototype.request=function(e,t,r,n){const s=this;let o=null;const a=Array.isArray(e)&&"function"==typeof t;if(1===this.options.version&&a)throw new TypeError("JSON-RPC 1.0 does not support batching");if(a||!a&&e&&"object"==typeof e&&"function"==typeof t)n=t,o=e;else{"function"==typeof r&&(n=r,r=void 0);const s="function"==typeof n;try{o=i(e,t,r,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(e){if(s)return n(e);throw e}if(!s)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(e){return n(e)}return this.callServer(c,(function(e,t){s._parseResponse(e,t,n)})),o},s.prototype._parseResponse=function(e,t,r){if(e)return void r(e);if(!t)return r();let n;try{n=JSON.parse(t,this.options.reviver)}catch(e){return r(e)}if(3===r.length){if(Array.isArray(n)){const e=function(e){return void 0!==e.error},t=function(t){return!e(t)};return r(null,n.filter(e),n.filter(t))}return r(null,n.error,n.result)}r(null,n)}},81435:(e,t,r)=>{"use strict";const n=r(81298).v4;e.exports=function(e,t,r,i){if("string"!=typeof e)throw new TypeError(e+" must be a string");const s="number"==typeof(i=i||{}).version?i.version:2;if(1!==s&&2!==s)throw new TypeError(s+" must be 1 or 2");const o={method:e};if(2===s&&(o.jsonrpc="2.0"),t){if("object"!=typeof t&&!Array.isArray(t))throw new TypeError(t+" must be an object, array or omitted");o.params=t}if(void 0===r){const e="function"==typeof i.generator?i.generator:function(){return n()};o.id=e(o,i)}else 2===s&&null===r?i.notificationIdNull&&(o.id=null):o.id=r;return o}},63387:e=>{"use strict";e.exports=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var o=e.length,a=e.charAt(0),c=Math.log(o)/Math.log(256),u=Math.log(256)/Math.log(o);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===a;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var l=t[e.charCodeAt(r)];if(255===l)return;for(var d=0,h=s-1;(0!==l||d<i)&&-1!==h;h--,d++)l+=o*u[h]>>>0,u[h]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");i=d,r++}for(var f=s-i;f!==s&&0===u[f];)f++;for(var p=new Uint8Array(n+(s-f)),g=n;f!==s;)p[g++]=u[f++];return p}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,l=new Uint8Array(c);i!==s;){for(var d=t[i],h=0,f=c-1;(0!==d||h<n)&&-1!==f;f--,h++)d+=256*l[f]>>>0,l[f]=d%o>>>0,d=d/o>>>0;if(0!==d)throw new Error("Non-zero carry");n=h,i++}for(var p=c-n;p!==c&&0===l[p];)p++;for(var g=a.repeat(r);p<c;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:l,decode:function(e){var t=l(e);if(t)return t;throw new Error("Non-base"+o+" character")}}}},67894:(e,t,r)=>{const n=r(63387);e.exports=n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},76745:(e,t,r)=>{"use strict";var n=Object.create,i=Object.defineProperty,s=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,a=Object.getPrototypeOf,c=Object.prototype.hasOwnProperty,u=(e,t,r,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of o(t))c.call(e,a)||a===r||i(e,a,{get:()=>t[a],enumerable:!(n=s(t,a))||n.enumerable});return e},l={};((e,t)=>{for(var r in t)i(e,r,{get:t[r],enumerable:!0})})(l,{fromB58:()=>f,toB58:()=>h}),e.exports=(e=>u(i({},"__esModule",{value:!0}),e))(l);var d=((e,t,r)=>(r=null!=e?n(a(e)):{},u(!t&&e&&e.__esModule?r:i(r,"default",{value:e,enumerable:!0}),e)))(r(67894));const h=e=>d.default.encode(e),f=e=>d.default.decode(e)},41635:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};function o(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{fromB64:()=>o,toB64:()=>c}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const a=8192;function c(e){if(e.length<a)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=a){const n=e.slice(r,r+a);t+=String.fromCharCode(...n)}return btoa(t)}},64968:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},c=(e,t,r)=>(a(e,t,"read from private field"),r?r.call(e):t.get(e)),u=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},l=(e,t,r,n)=>(a(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),d={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(d,{BcsType:()=>I,SerializedBcs:()=>x,bigUIntBcsType:()=>_,dynamicSizeBcsType:()=>T,fixedSizeBcsType:()=>A,isSerializedBcs:()=>E,lazyBcsType:()=>j,stringLikeBcsType:()=>P,uIntBcsType:()=>O}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(d);var h,f,p,g,m=r(76745),y=r(41635),b=r(19080),w=r(31642),S=r(17306),k=r(76622);const v=class{constructor(e){u(this,h,void 0),u(this,f,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),l(this,h,e.write),l(this,f,e.serialize??((e,t)=>{const r=new k.BcsWriter({size:this.serializedSize(e)??void 0,...t});return c(this,h).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),c(this,h).call(this,e,t)}serialize(e,t){return this.validate(e),new x(this,c(this,f).call(this,e,t))}parse(e){const t=new w.BcsReader(e);return this.read(t)}transform({name:e,input:t,output:r}){return new v({name:e??this.name,read:e=>r(this.read(e)),write:(e,r)=>c(this,h).call(this,t(e),r),serializedSize:e=>this.serializedSize(t(e)),serialize:(e,r)=>c(this,f).call(this,t(e),r),validate:e=>this.validate(t(e))})}};let I=v;h=new WeakMap,f=new WeakMap;const B=Symbol.for("@mysten/serialized-bcs");function E(e){return!!e&&"object"==typeof e&&!0===e[B]}class x{constructor(e,t){u(this,p,void 0),u(this,g,void 0),l(this,p,e),l(this,g,t)}get[B](){return!0}toBytes(){return c(this,g)}toHex(){return(0,b.toHEX)(c(this,g))}toBase64(){return(0,y.toB64)(c(this,g))}toBase58(){return(0,m.toB58)(c(this,g))}parse(){return c(this,p).parse(c(this,g))}}function A({size:e,...t}){return new I({...t,serializedSize:()=>e})}function O({readMethod:e,writeMethod:t,...r}){return A({...r,read:t=>t[e](),write:(e,r)=>r[t](e),validate:e=>{if(e<0||e>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected value in range 0-${r.maxValue}`);r.validate?.(e)}})}function _({readMethod:e,writeMethod:t,...r}){return A({...r,read:t=>t[e](),write:(e,r)=>r[t](BigInt(e)),validate:e=>{const t=BigInt(e);if(t<0||t>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${t}. Expected value in range 0-${r.maxValue}`);r.validate?.(t)}})}function T({serialize:e,...t}){const r=new I({...t,serialize:e,write:(e,t)=>{for(const n of r.serialize(e).toBytes())t.write8(n)}});return r}function P({toBytes:e,fromBytes:t,...r}){return new I({...r,read:e=>{const r=e.readULEB(),n=e.readBytes(r);return t(n)},write:(t,r)=>{const n=e(t);r.writeULEB(n.length);for(let e=0;e<n.length;e++)r.write8(n[e])},serialize:t=>{const r=e(t),n=(0,S.ulebEncode)(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{if("string"!=typeof e)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected string`);r.validate?.(e)}})}function j(e){let t=null;function r(){return t||(t=e()),t}return new I({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}p=new WeakMap,g=new WeakMap},78888:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{bcs:()=>l}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(64968),u=r(17306);const l={u8:e=>(0,c.uIntBcsType)({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>(0,c.uIntBcsType)({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>(0,c.uIntBcsType)({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>(0,c.bigUIntBcsType)({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>(0,c.bigUIntBcsType)({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>(0,c.bigUIntBcsType)({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>(0,c.fixedSizeBcsType)({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{if(e?.validate?.(t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>(0,c.dynamicSizeBcsType)({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from((0,u.ulebEncode)(e)),...e}),bytes:(e,t)=>(0,c.fixedSizeBcsType)({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{if(t?.validate?.(r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>(0,c.stringLikeBcsType)({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new c.BcsType({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{if(r?.validate?.(t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>l.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new c.BcsType({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{if(t?.validate?.(e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new c.BcsType({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{if(t?.validate?.(r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new c.BcsType({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new c.BcsType({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:i?.read(e)??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let e=0;e<n.length;e++){const[s,o]=n[e];if(s===r)return t.writeULEB(e),void o?.write(i,t)}},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const n=Object.keys(e);if(1!==n.length)throw new TypeError(`Expected object with one key, found ${n.length}`);const[i]=n;if(!Object.hasOwn(t,i))throw new TypeError(`Invalid enum variant ${i}`)}})},map:(e,t)=>l.vector(l.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>(...e)=>t(...e).transform({name:`${t.name}<${e.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e}),lazy:e=>(0,c.lazyBcsType)(e)}},19080:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};function o(e){const t=e.startsWith("0x")?e.slice(2):e,r=t.length%2==0?t:`0${t}}`,n=r.match(/.{2}/g)?.map((e=>parseInt(e,16)))??[];return Uint8Array.from(n)}function a(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{fromHEX:()=>o,toHEX:()=>a}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s)},1635:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e},c={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(c,{BcsReader:()=>p.BcsReader,BcsType:()=>d.BcsType,BcsWriter:()=>m.BcsWriter,SerializedBcs:()=>d.SerializedBcs,bcs:()=>h.bcs,decodeStr:()=>g.decodeStr,encodeStr:()=>g.encodeStr,fromB58:()=>u.fromB58,fromB64:()=>l.fromB64,fromHEX:()=>f.fromHEX,isSerializedBcs:()=>d.isSerializedBcs,splitGenericParameters:()=>g.splitGenericParameters,toB58:()=>u.toB58,toB64:()=>l.toB64,toHEX:()=>f.toHEX}),e.exports=(e=>a(n({},"__esModule",{value:!0}),e))(c);var u=r(76745),l=r(41635),d=r(64968),h=r(78888),f=r(19080),p=r(31642),g=r(60827),m=r(76622);((e,t,r)=>{a(e,t,"default"),r&&a(r,t,"default")})(c,r(20235),e.exports)},20235:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{BCS:()=>y,getRustConfig:()=>w,getSuiMoveConfig:()=>S,registerPrimitives:()=>b}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(76745),u=r(41635),l=r(64968),d=r(19080),h=r(31642),f=r(60827),p=r(76622);const g=32,m=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof m)return this.schema=e.schema,void(this.types=new Map(e.types));if(this.schema=e,this.registerAddressType(m.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);!1!==e.withPrimitives&&b(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new m(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(!r)throw new Error("To pass a string to `bcs.de`, specify encoding");t=(0,f.decodeStr)(t,r)}if("string"==typeof e||Array.isArray(e)){const{name:r,params:n}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,n)}if("object"==typeof e){const n=new m(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=(()=>!0)){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new p.BcsWriter(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new h.BcsReader(t),r,n)},_encodeRaw(e,r,s,o){if(n(r))return t.call(this,e,r,s,o);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new l.BcsType({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),o=this.getTypeInterface(i),a=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return o._encodeRaw.call(this,r,t,s,a)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new l.BcsType({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),o=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,o)}})));return t(...n).read(e)})),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,(function(e,t){return(0,u.fromB64)(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return(0,u.toB64)(e.readBytes(t))}));case"hex":return this.registerType(e,(function(e,t){return(0,d.fromHEX)(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return(0,d.toHEX)(e.readBytes(t))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:o,params:a}=this.parseTypeName(s);if(this.hasType(o))return this.getTypeInterface(o)._encodeRaw.call(this,t,r,a,i);if(!(o in i))throw new Error(`Unable to find a matching type definition for ${o} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[o]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:o}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,o,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:a,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(a)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,o,a){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(o.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${o.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:l}=this.parseTypeName(o[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],l,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:d,params:h}=this.parseTypeName(a[u]);this.getTypeInterface(d)._encodeRaw.call(this,e,t[c],h,a)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,a)}return e}),(function(e,t,o){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let a={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:l}=this.parseTypeName(t[r]);if(this.hasType(u)){a[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,l,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:d,params:h}=this.parseTypeName(o[u]);a[c]=this.getTypeInterface(d)._decodeRaw.call(this,e,h,o)}else a[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,o)}return a}))}registerEnumType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];null===n||Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,o,a){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let l=n[u],d=r[l];if(e.write8(u),null===d)return e;let h=s.indexOf(d),f=-1===h?d:o[h];{let{name:r,params:n}=this.parseTypeName(f);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,a)}}),(function(e,t,o){let a=e.readULEB(),c=n[a],u=r[c];if(-1===a)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${a}"`);if(null===u)return{[c]:!0};let l=s.indexOf(u),d=-1===l?u:t[l];{let{name:t,params:r}=this.parseTypeName(d);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,o)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:(0,f.splitGenericParameters)(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let y=m;function b(e){e.registerType(y.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),e.registerType(y.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),e.registerType(y.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),e.registerType(y.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),e.registerType(y.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),e.registerType(y.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),e.registerType(y.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),e.registerType(y.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),e.registerType(y.HEX,(function(e,t){return e.writeVec(Array.from((0,d.fromHEX)(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return(0,d.toHEX)(new Uint8Array(t))})),e.registerType(y.BASE58,(function(e,t){return e.writeVec(Array.from((0,c.fromB58)(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return(0,c.toB58)(new Uint8Array(t))})),e.registerType(y.BASE64,(function(e,t){return e.writeVec(Array.from((0,u.fromB64)(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return(0,u.toB64)(new Uint8Array(t))}))}function w(){return{genericSeparators:["<",">"],vectorType:"Vec",addressLength:g,addressEncoding:"hex"}}function S(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:g,addressEncoding:"hex"}}y.U8="u8",y.U16="u16",y.U32="u32",y.U64="u64",y.U128="u128",y.U256="u256",y.BOOL="bool",y.VECTOR="vector",y.ADDRESS="address",y.STRING="string",y.HEX="hex-string",y.BASE58="base58-string",y.BASE64="base64-string"},31642:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{BcsReader:()=>u}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(17306);class u{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=(0,c.ulebDecode)(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}},17306:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};function o(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}function a(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,0==(128&i))break;r+=7}return{value:t,length:n}}((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{ulebDecode:()=>a,ulebEncode:()=>o}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s)},60827:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{decodeStr:()=>h,encodeStr:()=>d,splitGenericParameters:()=>f}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(76745),u=r(41635),l=r(19080);function d(e,t){switch(t){case"base58":return(0,c.toB58)(e);case"base64":return(0,u.toB64)(e);case"hex":return(0,l.toHEX)(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function h(e,t){switch(t){case"base58":return(0,c.fromB58)(e);case"base64":return(0,u.fromB64)(e);case"hex":return(0,l.fromHEX)(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function f(e,t=["<",">"]){const[r,n]=t,i=[];let s="",o=0;for(let t=0;t<e.length;t++){const a=e[t];a===r&&o++,a===n&&o--,0!==o||","!==a?s+=a:(i.push(s.trim()),s="")}return i.push(s.trim()),i}},76622:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{BcsWriter:()=>l}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(17306),u=r(60827);class l{constructor({size:e=1024,maxSize:t,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return d(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return d(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return d(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return(0,c.ulebEncode)(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return(0,u.encodeStr)(this.toBytes(),e)}}function d(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}},46754:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{TypeTagSerializer:()=>d.TypeTagSerializer,bcs:()=>H,bcsRegistry:()=>f,isPureArg:()=>h}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(71731),l=r(65084),d=r(65084);function h(e){return void 0!==e.Pure}const f=new c.BCS({...(0,c.getSuiMoveConfig)(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function p(e){return c.bcs.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function g(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const m=c.bcs.bytes(u.SUI_ADDRESS_LENGTH).transform({input:e=>"string"==typeof e?(0,c.fromHEX)((0,u.normalizeSuiAddress)(e)):e,output:e=>(0,u.normalizeSuiAddress)((0,c.toHEX)(e))}),y=c.bcs.vector(c.bcs.u8()).transform({name:"ObjectDigest",input:e=>(0,c.fromB58)(e),output:e=>(0,c.toB58)(new Uint8Array(e))}),b=c.bcs.struct("SuiObjectRef",{objectId:m,version:c.bcs.u64(),digest:y}),w=c.bcs.struct("SharedObjectRef",{objectId:m,initialSharedVersion:c.bcs.u64(),mutable:c.bcs.bool()}),S=c.bcs.enum("ObjectArg",{ImmOrOwned:b,Shared:w,Receiving:b}),k=c.bcs.enum("CallArg",{Pure:c.bcs.vector(c.bcs.u8()),Object:S,ObjVec:c.bcs.vector(S)}),v=c.bcs.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:c.bcs.lazy((()=>v)),struct:c.bcs.lazy((()=>T)),u16:null,u32:null,u256:null}),I=g(c.bcs.enum("Argument",{GasCoin:null,Input:c.bcs.struct("Input",{index:c.bcs.u16()}),Result:c.bcs.struct("Result",{index:c.bcs.u16()}),NestedResult:c.bcs.struct("NestedResult",{index:c.bcs.u16(),resultIndex:c.bcs.u16()})})),B=c.bcs.struct("ProgrammableMoveCall",{package:m,module:c.bcs.string(),function:c.bcs.string(),type_arguments:c.bcs.vector(v),arguments:c.bcs.vector(I)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>l.TypeTagSerializer.parseFromStr(e,!0)));return{package:(0,u.normalizeSuiAddress)(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(l.TypeTagSerializer.tagToString)})}),E=g(c.bcs.enum("Transaction",{MoveCall:B,TransferObjects:c.bcs.struct("TransferObjects",{objects:c.bcs.vector(I),address:I}),SplitCoins:c.bcs.struct("SplitCoins",{coin:I,amounts:c.bcs.vector(I)}),MergeCoins:c.bcs.struct("MergeCoins",{destination:I,sources:c.bcs.vector(I)}),Publish:c.bcs.struct("Publish",{modules:c.bcs.vector(c.bcs.vector(c.bcs.u8())),dependencies:c.bcs.vector(m)}),MakeMoveVec:c.bcs.struct("MakeMoveVec",{type:(x=v,c.bcs.enum("Option",{None:null,Some:x})),objects:c.bcs.vector(I)}),Upgrade:c.bcs.struct("Upgrade",{modules:c.bcs.vector(c.bcs.vector(c.bcs.u8())),dependencies:c.bcs.vector(m),packageId:m,ticket:I})}));var x;const A=c.bcs.struct("ProgrammableTransaction",{inputs:c.bcs.vector(k),transactions:c.bcs.vector(E)}),O=c.bcs.enum("TransactionKind",{ProgrammableTransaction:A,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),_=c.bcs.enum("TransactionExpiration",{None:null,Epoch:p()}),T=c.bcs.struct("StructTag",{address:m,module:c.bcs.string(),name:c.bcs.string(),typeParams:c.bcs.vector(v)}),P=c.bcs.struct("GasData",{payment:c.bcs.vector(b),owner:m,price:c.bcs.u64(),budget:c.bcs.u64()}),j=c.bcs.struct("TransactionDataV1",{kind:O,sender:m,gasData:P,expiration:_}),C=c.bcs.enum("TransactionData",{V1:j}),R=c.bcs.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),z=c.bcs.enum("IntentVersion",{V0:null}),N=c.bcs.enum("AppId",{Sui:null}),U=c.bcs.struct("Intent",{scope:R,version:z,appId:N}),M=c.bcs.generic(["T"],(e=>c.bcs.struct("IntentMessage<T>",{intent:U,value:e}))),L=c.bcs.enum("CompressedSignature",{ED25519:c.bcs.fixedArray(64,c.bcs.u8()),Secp256k1:c.bcs.fixedArray(64,c.bcs.u8()),Secp256r1:c.bcs.fixedArray(64,c.bcs.u8()),ZkLogin:c.bcs.vector(c.bcs.u8())}),q=c.bcs.enum("PublicKey",{ED25519:c.bcs.fixedArray(32,c.bcs.u8()),Secp256k1:c.bcs.fixedArray(33,c.bcs.u8()),Secp256r1:c.bcs.fixedArray(33,c.bcs.u8()),ZkLogin:c.bcs.vector(c.bcs.u8())}),W=c.bcs.struct("MultiSigPkMap",{pubKey:q,weight:c.bcs.u8()}),K=c.bcs.struct("MultiSigPublicKey",{pk_map:c.bcs.vector(W),threshold:c.bcs.u16()}),D=c.bcs.struct("MultiSig",{sigs:c.bcs.vector(L),bitmap:c.bcs.u16(),multisig_pk:K}),$=c.bcs.vector(c.bcs.u8()).transform({input:e=>"string"==typeof e?(0,c.fromB64)(e):e,output:e=>(0,c.toB64)(new Uint8Array(e))}),V=c.bcs.struct("SenderSignedTransaction",{intentMessage:M(C),txSignatures:c.bcs.vector($)}),F=c.bcs.vector(V,{name:"SenderSignedData"}),H={...c.bcs,U8:c.bcs.u8(),U16:c.bcs.u16(),U32:c.bcs.u32(),U64:c.bcs.u64(),U128:c.bcs.u128(),U256:c.bcs.u256(),ULEB128:c.bcs.uleb128(),Bool:c.bcs.bool(),String:c.bcs.string(),Address:m,Argument:I,CallArg:k,CompressedSignature:L,GasData:P,MultiSig:D,MultiSigPkMap:W,MultiSigPublicKey:K,ObjectArg:S,ObjectDigest:y,ProgrammableMoveCall:B,ProgrammableTransaction:A,PublicKey:q,SenderSignedData:F,SenderSignedTransaction:V,SharedObjectRef:w,StructTag:T,SuiObjectRef:b,Transaction:E,TransactionData:C,TransactionDataV1:j,TransactionExpiration:_,TransactionKind:O,TypeTag:v,ser:f.ser.bind(f),de:f.de.bind(f),getTypeInterface:f.getTypeInterface.bind(f),hasType:f.hasType.bind(f),parseTypeName:f.parseTypeName.bind(f),registerAddressType:f.registerAddressType.bind(f),registerAlias:f.registerAlias.bind(f),registerBcsType:f.registerBcsType.bind(f),registerEnumType:f.registerEnumType.bind(f),registerStructType:f.registerStructType.bind(f),registerType:f.registerType.bind(f),types:f.types};f.registerBcsType("utf8string",(()=>c.bcs.string({name:"utf8string"}))),f.registerBcsType("unsafe_u64",(()=>p())),f.registerBcsType("enumKind",(e=>g(e))),[m,I,k,L,P,D,W,K,S,y,B,A,q,F,w,T,b,E,C,j,_,O,v].forEach((e=>{f.registerBcsType(e.name,(()=>e))}))},65084:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{TypeTagSerializer:()=>h}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(71731);const l=/^vector<(.+)>$/,d=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class h{static parseFromStr(e,t=!1){if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(l);if(r)return{vector:h.parseFromStr(r[1],t)};const n=e.match(d);if(n){return{struct:{address:t?(0,u.normalizeSuiAddress)(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:h.parseStructTypeArgs(n[5],t)}}}throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return(0,c.splitGenericParameters)(e).map((e=>h.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${h.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(h.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}},86079:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{SUI_CLIENT_BRAND:()=>f,SuiClient:()=>g,isSuiClient:()=>p}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(5417),l=r(71731),d=r(37785),h=r(55594);const f=Symbol.for("@mysten/SuiClient");function p(e){return"object"==typeof e&&null!==e&&!0===e[f]}class g{get[f](){return!0}constructor(e){this.transport=e.transport??new h.SuiHTTPTransport({url:e.url})}async getRpcApiVersion(){return(await this.transport.request({method:"rpc.discover",params:[]})).info.version}async getCoins(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getCoins",params:[e.owner,e.coinType,e.cursor,e.limit]})}async getAllCoins(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit]})}async getBalance(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getBalance",params:[e.owner,e.coinType]})}async getAllBalances(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner]})}async getCoinMetadata(e){return await this.transport.request({method:"suix_getCoinMetadata",params:[e.coinType]})}async getTotalSupply(e){return await this.transport.request({method:"suix_getTotalSupply",params:[e.coinType]})}async call(e,t){return await this.transport.request({method:e,params:t})}async getMoveFunctionArgTypes(e){return await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e.package,e.module,e.function]})}async getNormalizedMoveModulesByPackage(e){return await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e.package]})}async getNormalizedMoveModule(e){return await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e.package,e.module]})}async getNormalizedMoveFunction(e){return await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e.package,e.module,e.function]})}async getNormalizedMoveStruct(e){return await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e.package,e.module,e.struct]})}async getOwnedObjects(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:e.filter,options:e.options},e.cursor,e.limit]})}async getObject(e){if(!e.id||!(0,l.isValidSuiObjectId)((0,l.normalizeSuiObjectId)(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options]})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options]})}async multiGetObjects(e){e.ids.forEach((e=>{if(!e||!(0,l.isValidSuiObjectId)((0,l.normalizeSuiObjectId)(e)))throw new Error(`Invalid Sui Object id ${e}`)}));if(e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options]})}async queryTransactionBlocks(e){return await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e.filter,options:e.options},e.cursor,e.limit,"descending"===(e.order||"descending")]})}async getTransactionBlock(e){if(!(0,l.isValidTransactionDigest)(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options]})}async multiGetTransactionBlocks(e){e.digests.forEach((e=>{if(!(0,l.isValidTransactionDigest)(e))throw new Error(`Invalid Transaction digest ${e}`)}));if(e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options]})}async executeTransactionBlock(e){return await this.transport.request({method:"sui_executeTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:(0,c.toB64)(e.transactionBlock),Array.isArray(e.signature)?e.signature:[e.signature],e.options,e.requestType]})}async signAndExecuteTransactionBlock({transactionBlock:e,signer:t,...r}){let n;e instanceof Uint8Array?n=e:(e.setSenderIfNotSet(t.toSuiAddress()),n=await e.build({client:this}));const{signature:i,bytes:s}=await t.signTransactionBlock(n);return this.executeTransactionBlock({transactionBlock:s,signature:i,...r})}async getTotalTransactionBlocks(){const e=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[]});return BigInt(e)}async getReferenceGasPrice(){const e=await this.transport.request({method:"suix_getReferenceGasPrice",params:[]});return BigInt(e)}async getStakes(e){if(!e.owner||!(0,l.isValidSuiAddress)((0,l.normalizeSuiAddress)(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner]})}async getStakesByIds(e){return e.stakedSuiIds.forEach((e=>{if(!e||!(0,l.isValidSuiObjectId)((0,l.normalizeSuiObjectId)(e)))throw new Error(`Invalid Sui Stake id ${e}`)})),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds]})}async getLatestSuiSystemState(){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[]})}async queryEvents(e){return await this.transport.request({method:"suix_queryEvents",params:[e.query,e.cursor,e.limit,"descending"===(e.order||"descending")]})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage})}async devInspectTransactionBlock(e){let t;if((0,u.isTransactionBlock)(e.transactionBlock))e.transactionBlock.setSenderIfNotSet(e.sender),t=(0,c.toB64)(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if("string"==typeof e.transactionBlock)t=e.transactionBlock;else{if(!(e.transactionBlock instanceof Uint8Array))throw new Error("Unknown transaction block format.");t=(0,c.toB64)(e.transactionBlock)}return await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,t,e.gasPrice?.toString(),e.epoch]})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:(0,c.toB64)(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!(0,l.isValidSuiObjectId)((0,l.normalizeSuiObjectId)(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit]})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name]})}async getLatestCheckpointSequenceNumber(){const e=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[]});return String(e)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id]})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder]})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch]})}async getNetworkMetrics(){return await this.transport.request({method:"suix_getNetworkMetrics",params:[]})}async getAddressMetrics(){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[]})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder]})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getMoveCallMetrics(){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[]})}async getCurrentEpoch(){return await this.transport.request({method:"suix_getCurrentEpoch",params:[]})}async getValidatorsApy(){return await this.transport.request({method:"suix_getValidatorsApy",params:[]})}async getChainIdentifier(){const e=await this.getCheckpoint({id:"0"}),t=(0,c.fromB58)(e.digest);return(0,c.toHEX)(t.slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name]})}async resolveNameServiceNames({format:e="dot",...t}){const{nextCursor:r,hasNextPage:n,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit]});return{hasNextPage:n,nextCursor:r,data:i.map((t=>(0,d.normalizeSuiNSName)(t,e)))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version]})}async waitForTransactionBlock({signal:e,timeout:t=6e4,pollInterval:r=2e3,...n}){const i=AbortSignal.timeout(t),s=new Promise(((e,t)=>{i.addEventListener("abort",(()=>t(i.reason)))}));for(s.catch((()=>{}));!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(n)}catch(e){await Promise.race([new Promise((e=>setTimeout(e,r))),s])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}}},17750:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{JsonRpcError:()=>c,SuiHTTPStatusError:()=>u,SuiHTTPTransportError:()=>a}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const o={"-32700":"ParseError","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError"};class a extends Error{}class c extends a{constructor(e,t){super(e),this.code=t,this.type=o[t]??"ServerError"}}class u extends a{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}},55594:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},c=(e,t,r)=>(a(e,t,"read from private field"),r?r.call(e):t.get(e)),u=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},l=(e,t,r,n)=>(a(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),d={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(d,{SuiHTTPTransport:()=>S}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(d);var h,f,p,g,m,y=r(28031),b=r(17750),w=r(48035);class S{constructor(e){u(this,g),u(this,h,0),u(this,f,void 0),u(this,p,void 0),l(this,f,e)}fetch(e,t){const r=c(this,f).fetch??globalThis.fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){l(this,h,c(this,h)+1);const t=await this.fetch(c(this,f).rpc?.url??c(this,f).url,{method:"POST",headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":y.PACKAGE_VERSION,"Client-Target-Api-Version":y.TARGETED_RPC_VERSION,...c(this,f).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:c(this,h),method:e.method,params:e.params})});if(!t.ok)throw new b.SuiHTTPStatusError(`Unexpected status code: ${t.status}`,t.status,t.statusText);const r=await t.json();if("error"in r&&null!=r.error)throw new b.JsonRpcError(r.error.message,r.error.code);return r.result}async subscribe(e){const t=await(r=this,n=g,i=m,a(r,n,"access private method"),i).call(this).subscribe(e);var r,n,i;return async()=>!!await t()}}h=new WeakMap,f=new WeakMap,p=new WeakMap,g=new WeakSet,m=function(){if(!c(this,p)){const e=c(this,f).WebSocketConstructor??globalThis.WebSocket;if(!e)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");l(this,p,new w.WebsocketClient(c(this,f).websocket?.url??c(this,f).url,{WebSocketConstructor:e,...c(this,f).websocket}))}return c(this,p)}},83420:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e},c=(e,t,r)=>(a(e,t,"default"),r&&a(r,t,"default")),u={};e.exports=(e=>a(n({},"__esModule",{value:!0}),e))(u),c(u,r(55594),e.exports),c(u,r(25851),e.exports),c(u,r(33622),e.exports),c(u,r(86079),e.exports),c(u,r(17750),e.exports)},25851:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};function o(e){switch(e){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${e}`)}}((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{getFullnodeUrl:()=>o}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s)},48035:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},c=(e,t,r)=>(a(e,t,"read from private field"),r?r.call(e):t.get(e)),u=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},l=(e,t,r,n)=>(a(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),d=(e,t,r)=>(a(e,t,"access private method"),r),h={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(h,{DEFAULT_CLIENT_OPTIONS:()=>B,WebsocketClient:()=>E}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(h);var f,p,g,m,y,b,w,S,k,v,I=r(17750);const B={WebSocketConstructor:"undefined"!=typeof WebSocket?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class E{constructor(e,t={}){if(u(this,w),u(this,k),u(this,f,0),u(this,p,0),u(this,g,null),u(this,m,null),u(this,y,new Set),u(this,b,new Map),this.endpoint=e,this.options={...B,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=function(e){const t=new URL(e);return t.protocol=t.protocol.replace("http","ws"),t.toString()}(this.endpoint))}async makeRequest(e,t){const r=await d(this,w,S).call(this);return new Promise(((n,i)=>{l(this,f,c(this,f)+1),c(this,b).set(c(this,f),{resolve:n,reject:i,timeout:setTimeout((()=>{c(this,b).delete(c(this,f)),i(new Error(`Request timeout: ${e}`))}),this.options.callTimeout)}),r.send(JSON.stringify({jsonrpc:"2.0",id:c(this,f),method:e,params:t}))})).then((({error:e,result:t})=>{if(e)throw new I.JsonRpcError(e.message,e.code);return t}))}async subscribe(e){const t=new x(e);return c(this,y).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}f=new WeakMap,p=new WeakMap,g=new WeakMap,m=new WeakMap,y=new WeakMap,b=new WeakMap,w=new WeakSet,S=function(){return c(this,m)||l(this,m,new Promise((e=>{c(this,g)?.close(),l(this,g,new this.options.WebSocketConstructor(this.endpoint)),c(this,g).addEventListener("open",(()=>{l(this,p,0),e(c(this,g))})),c(this,g).addEventListener("close",(()=>{var e,t,r,n;(e=this,t=p,{set _(n){l(e,t,n,r)},get _(){return c(e,t,n)}})._++,c(this,p)<=this.options.maxReconnects&&setTimeout((()=>{d(this,k,v).call(this)}),this.options.reconnectTimeout)})),c(this,g).addEventListener("message",(({data:e})=>{let t;try{t=JSON.parse(e)}catch(t){return void console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:t}))}if("id"in t&&null!=t.id&&c(this,b).has(t.id)){const{resolve:e,timeout:r}=c(this,b).get(t.id);clearTimeout(r),e(t)}else if("params"in t){const{params:e}=t;c(this,y).forEach((t=>{t.subscriptionId===e.subscription&&e.subscription===t.subscriptionId&&t.onMessage(e.result)}))}}))}))),c(this,m)},k=new WeakSet,v=async function(){return c(this,g)?.close(),l(this,m,null),Promise.allSettled([...c(this,y)].map((e=>e.subscribe(this))))};class x{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,null!=t&&(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params);this.subscribed&&(this.subscriptionId=t)}}},14297:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},50874:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},45820:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},10227:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},93651:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},33622:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e},c=(e,t,r)=>(a(e,t,"default"),r&&a(r,t,"default")),u={};e.exports=(e=>a(n({},"__esModule",{value:!0}),e))(u),c(u,r(14297),e.exports),c(u,r(45820),e.exports),c(u,r(10227),e.exports),c(u,r(50874),e.exports),c(u,r(93651),e.exports),c(u,r(11651),e.exports)},11651:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty;e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))({})},13650:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{BuilderCallArg:()=>m,Inputs:()=>y,ObjectCallArg:()=>g,PureCallArg:()=>p,SuiObjectRef:()=>h,getIdFromCallArg:()=>b,getSharedObjectInput:()=>w,isMutableSharedObjectInput:()=>k,isSharedObjectInput:()=>S}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(14385),l=r(46754),d=r(71731);const h=(0,u.object)({digest:(0,u.string)(),objectId:(0,u.string)(),version:(0,u.union)([(0,u.number)(),(0,u.string)(),(0,u.bigint)()])}),f=(0,u.union)([(0,u.object)({ImmOrOwned:h}),(0,u.object)({Shared:(0,u.object)({objectId:(0,u.string)(),initialSharedVersion:(0,u.union)([(0,u.integer)(),(0,u.string)()]),mutable:(0,u.boolean)()})}),(0,u.object)({Receiving:h})]),p=(0,u.object)({Pure:(0,u.array)((0,u.integer)())}),g=(0,u.object)({Object:f}),m=(0,u.union)([p,g]);const y={Pure:function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:(0,c.isSerializedBcs)(e)?e.toBytes():l.bcs.ser(t,e,{maxSize:1/0}).toBytes())}},ObjectRef:({objectId:e,digest:t,version:r})=>({Object:{ImmOrOwned:{digest:t,version:r,objectId:(0,d.normalizeSuiAddress)(e)}}}),SharedObjectRef:({objectId:e,mutable:t,initialSharedVersion:r})=>({Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:(0,d.normalizeSuiAddress)(e)}}}),ReceivingRef:({objectId:e,digest:t,version:r})=>({Object:{Receiving:{digest:t,version:r,objectId:(0,d.normalizeSuiAddress)(e)}}})};function b(e){return"string"==typeof e?(0,d.normalizeSuiAddress)(e):"ImmOrOwned"in e.Object?(0,d.normalizeSuiAddress)(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?(0,d.normalizeSuiAddress)(e.Object.Receiving.objectId):(0,d.normalizeSuiAddress)(e.Object.Shared.objectId)}function w(e){return"object"==typeof e&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}function S(e){return!!w(e)}function k(e){return w(e)?.mutable??!1}},57125:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},c=(e,t,r)=>(a(e,t,"read from private field"),r?r.call(e):t.get(e)),u=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},l=(e,t,r,n)=>(a(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),d=(e,t,r)=>(a(e,t,"access private method"),r),h={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(h,{TransactionBlock:()=>G,isTransactionBlock:()=>F}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(h);var f,p,g,m,y,b,w,S,k,v,I,B,E,x,A,O,_,T=r(1635),P=r(14385),j=r(46754),C=r(76903),R=r(71731),z=r(13650),N=r(80939),U=r(95797),M=r(64575),L=r(60935),q=r(56574);const W={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function K(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const D=Symbol.for("@mysten/transaction"),$={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},V=1000n;function F(e){return!!e&&"object"==typeof e&&!0===e[D]}const H=class{constructor(e){u(this,p),u(this,m),u(this,b),u(this,S),u(this,v),u(this,B),u(this,x),u(this,O),u(this,f,void 0),l(this,f,new M.TransactionBlockDataBuilder(e?e.blockData:void 0))}static fromKind(e){const t=new H;return l(t,f,M.TransactionBlockDataBuilder.fromKindBytes("string"==typeof e?(0,T.fromB64)(e):e)),t}static from(e){const t=new H;return"string"==typeof e&&e.startsWith("{")?l(t,f,M.TransactionBlockDataBuilder.restore(JSON.parse(e))):l(t,f,M.TransactionBlockDataBuilder.fromBytes("string"==typeof e?(0,T.fromB64)(e):e)),t}setSender(e){c(this,f).sender=e}setSenderIfNotSet(e){c(this,f).sender||(c(this,f).sender=e)}setExpiration(e){c(this,f).expiration=e}setGasPrice(e){c(this,f).gasConfig.price=String(e)}setGasBudget(e){c(this,f).gasConfig.budget=String(e)}setGasOwner(e){c(this,f).gasConfig.owner=e}setGasPayment(e){c(this,f).gasConfig.payment=e.map((e=>(0,P.mask)(e,z.SuiObjectRef)))}get blockData(){return c(this,f).snapshot()}get[D](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:(0,N.createPure)(((e,t)=>(0,T.isSerializedBcs)(e)?d(this,p,g).call(this,"pure",{Pure:Array.from(e.toBytes())}):d(this,p,g).call(this,"pure",e instanceof Uint8Array?z.Inputs.Pure(e):t?z.Inputs.Pure(e,t):e)))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if("object"==typeof e&&"kind"in e)return e;const t=(0,z.getIdFromCallArg)(e),r=c(this,f).inputs.find((e=>"object"===e.type&&t===(0,z.getIdFromCallArg)(e.value)));return r&&(0,P.is)(r.value,z.ObjectCallArg)&&"Shared"in r.value.Object&&(0,P.is)(e,z.ObjectCallArg)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??d(this,p,g).call(this,"object","string"==typeof e?(0,R.normalizeSuiAddress)(e):e)}objectRef(...e){return this.object(z.Inputs.ObjectRef(...e))}receivingRef(...e){return this.object(z.Inputs.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(z.Inputs.SharedObjectRef(...e))}add(e){return function(e){const t=[],r=r=>t[r]??(t[r]={kind:"NestedResult",index:e,resultIndex:r});return new Proxy({kind:"Result",index:e},{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(e,t){if(t in e)return Reflect.get(e,t);if(t===Symbol.iterator)return function*(){let e=0;for(;;)yield r(e),e++};if("symbol"==typeof t)return;const n=parseInt(t,10);return Number.isNaN(n)||n<0?void 0:r(n)}})}(c(this,f).transactions.push(e)-1)}splitCoins(e,t){return this.add(L.Transactions.SplitCoins("string"==typeof e?this.object(e):e,t.map((e=>"number"==typeof e||"bigint"==typeof e||"string"==typeof e?this.pure.u64(e):d(this,m,y).call(this,e)))))}mergeCoins(e,t){return this.add(L.Transactions.MergeCoins("string"==typeof e?this.object(e):e,t.map((e=>"string"==typeof e?this.object(e):e))))}publish({modules:e,dependencies:t}){return this.add(L.Transactions.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return this.add(L.Transactions.Upgrade({modules:e,dependencies:t,packageId:r,ticket:"string"==typeof n?this.object(n):n}))}moveCall({arguments:e,typeArguments:t,target:r}){return this.add(L.Transactions.MoveCall({arguments:e?.map((e=>d(this,m,y).call(this,e))),typeArguments:t,target:r}))}transferObjects(e,t){return this.add(L.Transactions.TransferObjects(e.map((e=>"string"==typeof e?this.object(e):e)),"string"==typeof t?this.pure.address(t):d(this,m,y).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(L.Transactions.MakeMoveVec({type:e,objects:t.map((e=>"string"==typeof e?this.object(e):e))}))}serialize(){return JSON.stringify(c(this,f).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(e={}){return await d(this,O,_).call(this,e),c(this,f).build({maxSizeBytes:d(this,b,w).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await d(this,O,_).call(this,e),c(this,f).getDigest()}};let G=H;f=new WeakMap,p=new WeakSet,g=function(e,t){const r=c(this,f).inputs.length,n=(0,q.create)({kind:"Input",value:"bigint"==typeof t?String(t):t,index:r,type:e},L.TransactionBlockInput);return c(this,f).inputs.push(n),n},m=new WeakSet,y=function(e){return(0,T.isSerializedBcs)(e)?this.pure(e):e},b=new WeakSet,w=function(e,{protocolConfig:t,limits:r}){if(r&&"number"==typeof r[e])return r[e];if(!t)return W[e];const n=t?.attributes[$[e]];if(!n)throw new Error(`Missing expected protocol config: "${$[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${$[e]}"`);return Number(i)},S=new WeakSet,k=function(e){const t=d(this,b,w).call(this,"maxPureArgumentSize",e);c(this,f).inputs.forEach(((e,r)=>{if((0,P.is)(e.value,z.PureCallArg)&&e.value.Pure.length>t)throw new Error(`Input at index ${r} is too large, max pure input size is ${t} bytes, got ${e.value.Pure.length} bytes`)}))},v=new WeakSet,I=async function(e){if(c(this,f).gasConfig.payment){const t=d(this,b,w).call(this,"maxGasObjects",e);if(c(this,f).gasConfig.payment.length>t)throw new Error(`Payment objects exceed maximum amount: ${t}`)}if(e.onlyTransactionKind||c(this,f).gasConfig.payment)return;const t=c(this,f).gasConfig.owner??c(this,f).sender,r=(await K(e).getCoins({owner:t,coinType:C.SUI_TYPE_ARG})).data.filter((e=>!c(this,f).inputs.find((t=>!!((0,P.is)(t.value,z.BuilderCallArg)&&"Object"in t.value&&"ImmOrOwned"in t.value.Object)&&e.coinObjectId===t.value.Object.ImmOrOwned.objectId)))).slice(0,d(this,b,w).call(this,"maxGasObjects",e)-1).map((e=>({objectId:e.coinObjectId,digest:e.digest,version:e.version})));if(!r.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(r)},B=new WeakSet,E=async function(e){e.onlyTransactionKind||c(this,f).gasConfig.price||this.setGasPrice(await K(e).getReferenceGasPrice())},x=new WeakSet,A=async function(e){const{inputs:t,transactions:r}=c(this,f),n=[],i=[];if(t.forEach((e=>{"object"!==e.type||"string"!=typeof e.value||i.push({id:(0,R.normalizeSuiAddress)(e.value),input:e})})),r.forEach((e=>{if("MoveCall"===e.kind){e.arguments.some((e=>"Input"===e.kind&&!(0,P.is)(t[e.index].value,z.BuilderCallArg)))&&n.push(e)}if("SplitCoins"===e.kind&&e.amounts.forEach((e=>{if("Input"===e.kind){const r=t[e.index];"object"!=typeof r.value&&(r.value=z.Inputs.Pure(j.bcs.U64.serialize(r.value)))}})),"TransferObjects"===e.kind&&"Input"===e.address.kind){const r=t[e.address.index];"object"!=typeof r.value&&(r.value=z.Inputs.Pure(j.bcs.Address.serialize(r.value)))}})),n.length&&await Promise.all(n.map((async r=>{const[n,s,o]=r.target.split("::"),a=await K(e).getNormalizedMoveFunction({package:(0,R.normalizeSuiObjectId)(n),module:s,function:o}),c=a.parameters.length>0&&(0,U.isTxContext)(a.parameters.at(-1))?a.parameters.slice(0,a.parameters.length-1):a.parameters;if(c.length!==r.arguments.length)throw new Error("Incorrect number of arguments.");c.forEach(((e,n)=>{const s=r.arguments[n];if("Input"!==s.kind)return;const o=t[s.index];if((0,P.is)(o.value,z.BuilderCallArg))return;const a=o.value,c=(0,U.getPureSerializationType)(e,a);if(c)return void(o.value=z.Inputs.Pure(a,c));if(!(null!=(0,q.extractStructTag)(e)||"object"==typeof e&&"TypeParameter"in e))throw new Error(`Unknown call arg type ${JSON.stringify(e,null,2)} for value ${JSON.stringify(a,null,2)}`);if("string"!=typeof a)throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(a,null,2)}`);i.push({id:a,input:o,normalizedType:e})}))}))),i.length){const t=[...new Set(i.map((({id:e})=>e)))],r=(s=t,o=50,Array.from({length:Math.ceil(s.length/o)},((e,t)=>s.slice(t*o,t*o+o)))),n=(await Promise.all(r.map((t=>K(e).multiGetObjects({ids:t,options:{showOwner:!0}}))))).flat();let a=new Map(t.map(((e,t)=>[e,n[t]])));const c=Array.from(a).filter((([e,t])=>t.error)).map((([e,t])=>e));if(c.length)throw new Error(`The following input objects are invalid: ${c.join(", ")}`);i.forEach((({id:e,input:t,normalizedType:r})=>{const n=a.get(e),i=n.data?.owner,s=i&&"object"==typeof i&&"Shared"in i?i.Shared.initial_shared_version:void 0;if(s){const n=null!=r&&null==(0,q.extractMutableReference)(r)&&null==(0,q.extractReference)(r),i=(0,z.isMutableSharedObjectInput)(t.value)||n||null!=r&&null!=(0,q.extractMutableReference)(r);t.value=z.Inputs.SharedObjectRef({objectId:e,initialSharedVersion:s,mutable:i})}else r&&function(e){const t=(0,q.extractStructTag)(e);return!!t&&"0x2"===t.Struct.address&&"transfer"===t.Struct.module&&"Receiving"===t.Struct.name}(r)?t.value=z.Inputs.ReceivingRef(n.data):t.value=z.Inputs.ObjectRef(n.data)}))}var s,o},O=new WeakSet,_=async function(e){if(!e.onlyTransactionKind&&!c(this,f).sender)throw new Error("Missing transaction sender");if(e.protocolConfig||e.limits||!e.client||(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([d(this,B,E).call(this,e),d(this,x,A).call(this,e)]),!e.onlyTransactionKind&&(await d(this,v,I).call(this,e),!c(this,f).gasConfig.budget)){const t=await K(e).dryRunTransactionBlock({transactionBlock:c(this,f).build({maxSizeBytes:d(this,b,w).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(d(this,b,w).call(this,"maxTxGas",e)),payment:[]}}})});if("success"!==t.effects.status.status)throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=V*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}d(this,S,k).call(this,e)}},64575:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{SerializedTransactionDataBuilder:()=>w,TransactionBlockDataBuilder:()=>k,TransactionExpiration:()=>m}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(14385),l=r(46754),d=r(71731),h=r(66901),f=r(13650),p=r(60935),g=r(56574);const m=(0,u.optional)((0,u.nullable)((0,u.union)([(0,u.object)({Epoch:(0,u.integer)()}),(0,u.object)({None:(0,u.union)([(0,u.literal)(!0),(0,u.literal)(null)])})]))),y=(0,u.define)("StringEncodedBigint",(e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}})),b=(0,u.object)({budget:(0,u.optional)(y),price:(0,u.optional)(y),payment:(0,u.optional)((0,u.array)(f.SuiObjectRef)),owner:(0,u.optional)((0,u.string)())}),w=(0,u.object)({version:(0,u.literal)(1),sender:(0,u.optional)((0,u.string)()),expiration:m,gasConfig:b,inputs:(0,u.array)(p.TransactionBlockInput),transactions:(0,u.array)(p.TransactionType)});function S(e){return(0,d.normalizeSuiAddress)(e).replace("0x","")}class k{constructor(e){this.version=1,this.sender=e?.sender,this.expiration=e?.expiration,this.gasConfig=e?.gasConfig??{},this.inputs=e?.inputs??[],this.transactions=e?.transactions??[]}static fromKindBytes(e){const t=l.bcs.TransactionKind.parse(e),r="ProgrammableTransaction"in t?t.ProgrammableTransaction:null;if(!r)throw new Error("Unable to deserialize from bytes.");const n=(0,g.create)({version:1,gasConfig:{},inputs:r.inputs.map(((e,t)=>(0,g.create)({kind:"Input",value:e,index:t,type:(0,u.is)(e,f.PureCallArg)?"pure":"object"},p.TransactionBlockInput))),transactions:r.transactions},w);return k.restore(n)}static fromBytes(e){const t=l.bcs.TransactionData.parse(e),r=t?.V1,n="ProgrammableTransaction"in r.kind?r?.kind?.ProgrammableTransaction:null;if(!r||!n)throw new Error("Unable to deserialize from bytes.");const i=(0,g.create)({version:1,sender:r.sender,expiration:r.expiration,gasConfig:r.gasData,inputs:n.inputs.map(((e,t)=>(0,g.create)({kind:"Input",value:e,index:t,type:(0,u.is)(e,f.PureCallArg)?"pure":"object"},p.TransactionBlockInput))),transactions:n.transactions},w);return k.restore(i)}static restore(e){(0,u.assert)(e,w);const t=new k;return Object.assign(t,e),t}static getDigestFromBytes(e){const t=(0,h.hashTypedData)("TransactionData",e);return(0,c.toB58)(t)}build({maxSizeBytes:e=1/0,overrides:t,onlyTransactionKind:r}={}){const n=this.inputs.map((e=>((0,u.assert)(e.value,f.BuilderCallArg),e.value))),i={ProgrammableTransaction:{inputs:n,transactions:this.transactions}};if(r)return l.bcs.TransactionKind.serialize(i,{maxSize:e}).toBytes();const s=t?.expiration??this.expiration,o=t?.sender??this.sender,a={...this.gasConfig,...t?.gasConfig};if(!o)throw new Error("Missing transaction sender");if(!a.budget)throw new Error("Missing gas budget");if(!a.payment)throw new Error("Missing gas payment");if(!a.price)throw new Error("Missing gas price");const c={sender:S(o),expiration:s||{None:!0},gasData:{payment:a.payment,owner:S(this.gasConfig.owner??o),price:BigInt(a.price),budget:BigInt(a.budget)},kind:{ProgrammableTransaction:{inputs:n,transactions:this.transactions}}};return l.bcs.TransactionData.serialize({V1:c},{maxSize:e}).toBytes()}getDigest(){const e=this.build({onlyTransactionKind:!1});return k.getDigestFromBytes(e)}snapshot(){return(0,g.create)(this,w)}}},60935:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{MakeMoveVecTransaction:()=>v,MergeCoinsTransaction:()=>k,MoveCallTransaction:()=>b,PublishTransaction:()=>B,SplitCoinsTransaction:()=>S,TransactionArgument:()=>y,TransactionBlockInput:()=>g,TransactionType:()=>O,Transactions:()=>T,TransferObjectsTransaction:()=>w,UpgradePolicy:()=>E,UpgradeTransaction:()=>x,getTransactionType:()=>_}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635),u=r(14385),l=r(46754),d=r(65084),h=r(71731),f=r(13650),p=r(56574);const g=(0,u.union)([(0,u.object)({kind:(0,u.literal)("Input"),index:(0,u.integer)(),value:(0,u.optional)((0,u.any)()),type:(0,u.optional)((0,u.literal)("object"))}),(0,u.object)({kind:(0,u.literal)("Input"),index:(0,u.integer)(),value:(0,u.optional)((0,u.any)()),type:(0,u.literal)("pure")})]),m=[g,(0,u.object)({kind:(0,u.literal)("GasCoin")}),(0,u.object)({kind:(0,u.literal)("Result"),index:(0,u.integer)()}),(0,u.object)({kind:(0,u.literal)("NestedResult"),index:(0,u.integer)(),resultIndex:(0,u.integer)()})],y=(0,u.union)([...m]),b=(0,u.object)({kind:(0,u.literal)("MoveCall"),target:(0,u.define)("target",(0,u.string)().validator),typeArguments:(0,u.array)((0,u.string)()),arguments:(0,u.array)(y)}),w=(0,u.object)({kind:(0,u.literal)("TransferObjects"),objects:(0,u.array)(y),address:y}),S=(0,u.object)({kind:(0,u.literal)("SplitCoins"),coin:y,amounts:(0,u.array)(y)}),k=(0,u.object)({kind:(0,u.literal)("MergeCoins"),destination:y,sources:(0,u.array)(y)}),v=(0,u.object)({kind:(0,u.literal)("MakeMoveVec"),type:(0,u.optional)((I=(0,u.record)((0,u.string)(),(0,u.unknown)()),(0,u.union)([(0,u.object)({None:(0,u.union)([(0,u.literal)(!0),(0,u.literal)(null)])}),(0,u.object)({Some:I})]))),objects:(0,u.array)(y)});var I;const B=(0,u.object)({kind:(0,u.literal)("Publish"),modules:(0,u.array)((0,u.array)((0,u.integer)())),dependencies:(0,u.array)((0,u.string)())});var E=(e=>(e[e.COMPATIBLE=0]="COMPATIBLE",e[e.ADDITIVE=128]="ADDITIVE",e[e.DEP_ONLY=192]="DEP_ONLY",e))(E||{});const x=(0,u.object)({kind:(0,u.literal)("Upgrade"),modules:(0,u.array)((0,u.array)((0,u.integer)())),dependencies:(0,u.array)((0,u.string)()),packageId:(0,u.string)(),ticket:y}),A=[b,w,S,k,B,x,v],O=(0,u.union)([...A]);function _(e){return(0,u.assert)(e,O),A.find((t=>(0,u.is)(e,t)))}const T={MoveCall:e=>(0,p.create)({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},b),TransferObjects:(e,t)=>("Input"===t.kind&&"pure"===t.type&&"object"!=typeof t.value&&(t.value=f.Inputs.Pure(l.bcs.Address.serialize(t.value))),(0,p.create)({kind:"TransferObjects",objects:e,address:t},w)),SplitCoins:(e,t)=>(t.forEach((e=>{"Input"===e.kind&&"pure"===e.type&&"object"!=typeof e.value&&(e.value=f.Inputs.Pure(l.bcs.U64.serialize(e.value)))})),(0,p.create)({kind:"SplitCoins",coin:e,amounts:t},S)),MergeCoins:(e,t)=>(0,p.create)({kind:"MergeCoins",destination:e,sources:t},k),Publish:({modules:e,dependencies:t})=>(0,p.create)({kind:"Publish",modules:e.map((e=>"string"==typeof e?Array.from((0,c.fromB64)(e)):e)),dependencies:t.map((e=>(0,h.normalizeSuiObjectId)(e)))},B),Upgrade:({modules:e,dependencies:t,packageId:r,ticket:n})=>(0,p.create)({kind:"Upgrade",modules:e.map((e=>"string"==typeof e?Array.from((0,c.fromB64)(e)):e)),dependencies:t.map((e=>(0,h.normalizeSuiObjectId)(e))),packageId:r,ticket:n},x),MakeMoveVec:({type:e,objects:t})=>(0,p.create)({kind:"MakeMoveVec",type:e?{Some:d.TypeTagSerializer.parseFromStr(e)}:{None:null},objects:t},v)}},21165:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{ARGUMENT:()=>v,ARGUMENT_INNER:()=>o,CALL_ARG:()=>u,COMPRESSED_SIGNATURE:()=>g,ENUM_KIND:()=>S,MULTISIG:()=>w,MULTISIG_PK_MAP:()=>b,MULTISIG_PUBLIC_KEY:()=>y,OBJECT_ARG:()=>d,OPTION:()=>c,PROGRAMMABLE_CALL:()=>I,PROGRAMMABLE_CALL_INNER:()=>f,PROGRAMMABLE_TX_BLOCK:()=>h,PUBLIC_KEY:()=>m,TRANSACTION:()=>k,TRANSACTION_INNER:()=>p,TYPE_TAG:()=>l,VECTOR:()=>a}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const o="Argument",a="vector",c="Option",u="CallArg",l="TypeTag",d="ObjectArg",h="ProgrammableTransaction",f="ProgrammableMoveCall",p="Transaction",g="CompressedSignature",m="PublicKey",y="MultiSigPublicKey",b="MultiSigPkMap",w="MultiSig",S="EnumKind",k=p,v=o,I="ProgrammableMoveCall"},66901:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{hashTypedData:()=>u}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(27327);function u(e,t){const r=Array.from(`${e}::`).map((e=>e.charCodeAt(0))),n=new Uint8Array(r.length+t.length);return n.set(r),n.set(t,r.length),(0,c.blake2b)(n,{dkLen:32})}},5417:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e},c=(e,t,r)=>(a(e,t,"default"),r&&a(r,t,"default")),u={};e.exports=(e=>a(n({},"__esModule",{value:!0}),e))(u),c(u,r(57125),e.exports),c(u,r(60935),e.exports),c(u,r(13650),e.exports),c(u,r(95797),e.exports),c(u,r(21165),e.exports)},80939:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{createPure:()=>u}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(46754);function u(e){function t(t,r){return e(t,r)}return t.u8=t=>e(c.bcs.U8.serialize(t)),t.u16=t=>e(c.bcs.U16.serialize(t)),t.u32=t=>e(c.bcs.U32.serialize(t)),t.u64=t=>e(c.bcs.U64.serialize(t)),t.u128=t=>e(c.bcs.U128.serialize(t)),t.u256=t=>e(c.bcs.U256.serialize(t)),t.bool=t=>e(c.bcs.Bool.serialize(t)),t.string=t=>e(c.bcs.String.serialize(t)),t.address=t=>e(c.bcs.Address.serialize(t)),t.id=t.address,t}},95797:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{getPureSerializationType:()=>w,isTxContext:()=>m}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(76903),u=r(71731),l=r(56574);const d={address:c.SUI_FRAMEWORK_ADDRESS,module:"object",name:"ID"},h={address:c.MOVE_STDLIB_ADDRESS,module:"ascii",name:"String"},f={address:c.MOVE_STDLIB_ADDRESS,module:"string",name:"String"},p={address:c.MOVE_STDLIB_ADDRESS,module:"option",name:"Option"},g=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function m(e){const t=(0,l.extractStructTag)(e)?.Struct;return"0x2"===t?.address&&"tx_context"===t?.module&&"TxContext"===t?.name}function y(e,t){if(void 0!==t&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const b=["Address","Bool","U8","U16","U32","U64","U128","U256"];function w(e,t){if("string"==typeof e&&b.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])y("number",t);else if("Bool"===e)y("boolean",t);else if("Address"===e&&(y("string",t),t&&!(0,u.isValidSuiAddress)(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=w(e.Vector,t?t[0]:void 0);if(void 0===r)return;return`vector<${r}>`}if("Struct"in e){if(g(e.Struct,h))return"string";if(g(e.Struct,f))return"utf8string";if(g(e.Struct,d))return"address";if(g(e.Struct,p)){return w({Vector:e.Struct.typeArguments[0]},t)}}}},56574:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{create:()=>u,extractMutableReference:()=>l,extractReference:()=>d,extractStructTag:()=>h}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(14385);function u(e,t){return(0,c.create)(e,t)}function l(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function d(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function h(e){if("object"==typeof e&&"Struct"in e)return e;const t=d(e),r=l(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}},27143:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{formatAddress:()=>a,formatDigest:()=>c}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const o="";function a(e){if(e.length<=6)return e;const t=e.startsWith("0x")?2:0;return`0x${e.slice(t,t+4)}${o}${e.slice(-4)}`}function c(e){return`${e.slice(0,10)}${o}`}},76903:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{MIST_PER_SUI:()=>p,MOVE_STDLIB_ADDRESS:()=>g,SUI_ADDRESS_LENGTH:()=>u.SUI_ADDRESS_LENGTH,SUI_CLOCK_OBJECT_ID:()=>b,SUI_DECIMALS:()=>f,SUI_FRAMEWORK_ADDRESS:()=>m,SUI_SYSTEM_ADDRESS:()=>y,SUI_SYSTEM_MODULE_NAME:()=>w,SUI_SYSTEM_STATE_OBJECT_ID:()=>k,SUI_TYPE_ARG:()=>S,assert:()=>d.assert,formatAddress:()=>c.formatAddress,formatDigest:()=>c.formatDigest,fromB64:()=>l.fromB64,fromHEX:()=>l.fromHEX,is:()=>d.is,isValidSuiAddress:()=>u.isValidSuiAddress,isValidSuiNSName:()=>h.isValidSuiNSName,isValidSuiObjectId:()=>u.isValidSuiObjectId,isValidTransactionDigest:()=>u.isValidTransactionDigest,normalizeStructTag:()=>u.normalizeStructTag,normalizeSuiAddress:()=>u.normalizeSuiAddress,normalizeSuiNSName:()=>h.normalizeSuiNSName,normalizeSuiObjectId:()=>u.normalizeSuiObjectId,parseStructTag:()=>u.parseStructTag,toB64:()=>l.toB64,toHEX:()=>l.toHEX}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(27143),u=r(71731),l=r(1635),d=r(14385),h=r(37785);const f=9,p=BigInt(1e9),g="0x1",m="0x2",y="0x3",b=(0,u.normalizeSuiObjectId)("0x6"),w="sui_system",S=`${m}::sui::SUI`,k=(0,u.normalizeSuiObjectId)("0x5")},71731:(e,t,r)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,s=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={};((e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:!0})})(a,{SUI_ADDRESS_LENGTH:()=>d,isValidSuiAddress:()=>h,isValidSuiObjectId:()=>f,isValidTransactionDigest:()=>l,normalizeStructTag:()=>g,normalizeSuiAddress:()=>m,normalizeSuiObjectId:()=>y,parseStructTag:()=>p}),e.exports=(e=>((e,t,r,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of s(t))o.call(e,c)||c===r||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),e))(a);var c=r(1635);const u=32;function l(e){try{return(0,c.fromB58)(e).length===u}catch(e){return!1}}const d=32;function h(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2==0}(e)&&function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)===d}function f(e){return h(e)}function p(e){const[t,r]=e.split("::"),n=e.slice(t.length+r.length+4),i=n.includes("<")?n.slice(0,n.indexOf("<")):n,s=n.includes("<")?(0,c.splitGenericParameters)(n.slice(n.indexOf("<")+1,n.lastIndexOf(">"))).map((e=>function(e){return e.includes("::")?p(e):e}(e.trim()))):[];return{address:m(t),module:r,name:i,typeParams:s}}function g(e){const{address:t,module:r,name:n,typeParams:i}="string"==typeof e?p(e):e;return`${t}::${r}::${n}${i?.length>0?`<${i.map((e=>"string"==typeof e?e:g(e))).join(",")}>`:""}`}function m(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(2*d,"0")}`}function y(e,t=!1){return m(e,t)}},37785:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{isValidSuiNSName:()=>u,normalizeSuiNSName:()=>l}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const o=/^(?:[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*)?@[a-z0-9][a-z0-9-]{0,62}$/i,a=/^(?:[a-z0-9][a-z0-9-]{0,62}\.)+sui$/i,c=235;function u(e){return!(e.length>c)&&(e.includes("@")?o.test(e):a.test(e))}function l(e,t="at"){const r=e.toLowerCase();let n;if(r.includes("@")){if(!o.test(r))throw new Error(`Invalid SuiNS name ${e}`);const[t,i]=r.split("@");n=[...t?t.split("."):[],i]}else{if(!a.test(r))throw new Error(`Invalid SuiNS name ${e}`);n=r.split(".").slice(0,-1)}return"dot"===t?`${n.join(".")}.sui`:`${n.slice(0,-1).join(".")}@${n[n.length-1]}`}},28031:e=>{"use strict";var t=Object.defineProperty,r=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.prototype.hasOwnProperty,s={};((e,r)=>{for(var n in r)t(e,n,{get:r[n],enumerable:!0})})(s,{PACKAGE_VERSION:()=>o,TARGETED_RPC_VERSION:()=>a}),e.exports=(e=>((e,s,o,a)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let c of n(s))i.call(e,c)||c===o||t(e,c,{get:()=>s[c],enumerable:!(a=r(s,c))||a.enumerable});return e})(t({},"__esModule",{value:!0}),e))(s);const o="0.54.1",a="1.25.0"}}]);